{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7a98a817_3c897e7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-10-14T06:23:21Z",
      "side": 1,
      "message": "First off, I\u0027m not sure if we want to actually do this.\n\nSecond of all, I have been struggling with the const correctness issues inherent in EncodedFrame for quite some time, and wanted some additional opinions around how best to solve it.\n\nThe current way we handle the const correctness issue is we very softly pinky swear to never modify the buffer if it is const, but we don\u0027t keep track of that anywhere currently. I have a similar bug I want to resolve for media::VideoFrame in Chrome:\nhttps://bugs.chromium.org/p/chromium/issues/detail?id\u003d1316810\n\nThe approach in this patch is to have a std::variant\u003cuint8_t*, const uint8_t*\u003e, and keep track of if the variant is const and provide helper methods for getting the data as const or mutable.\n\nOther ideas I had:\n\n1. Template EncodedFrame to have using MutableEncodedFrame \u003d EncodedFrame\u003cuint8_t*\u003e; I don\u0027t like this because now the entire class has to be a template for one field. I am open to this approach if we like it better however.\n\n2. Deal with it and do nothing. Don\u0027t love this one either.\n\n3. Don\u0027t use std::variant, and don\u0027t use C++17, just store as const uint8_t* and then keep a bool for \"is_mutable\" and provide a mutable_data() method that does a const_cast after DCHECK(is_mutable). This is not the worst idea, but requires the client to set is_mutable \u003d true.\n\n4. Have two child classes, MutableEncodedFrame and ReadOnlyEncodedFrame, that have different data fields. This is somewhat undesirable for inheritance reasons, but EncryptedFrame could just inherit from MutableEncodedFrame. We don\u0027t currently have any child classes that need to support both ready only and mutable cases, so this approach isn\u0027t crazy.\n\nWDYT? I like this approach less now that I\u0027ve put it out in the wild, but would love to have a general solution for handling fields that need to be const or non-const in different contexts that\u0027s safer than just hoping for the best but also not obnoxious to work with.",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90c3ec35_5c1ad031",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1328910
      },
      "writtenOn": "2022-10-14T17:17:08Z",
      "side": 1,
      "message": "std::variant is banned in Chromium at least, with absl::variant being preferred: https://chromium.googlesource.com/chromium/src/+/main/styleguide/c++/c++-features.md#std_variant-banned\n\nDoes OpenScreen follow Chromium style guide or something else?",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e34b66b_af3ba530",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1313149
      },
      "writtenOn": "2022-10-14T17:27:04Z",
      "side": 1,
      "message": "I think the first question is: do you want to have an immutable data type, or a type that is const-correct? What exactly is the problem in making the type mutable, but const-correct, and passing `std::unique_ptr\u003cconst EncodedFrame\u003e` / `const EncodedFrame\u0026` / `EncodedFrame const*` around for the cases where it shouldn\u0027t be mutated? This\u0027d require that we never expose a const method that mutates the buffer, which\u0027d be tricky to enforce, but maybe workable?\n\nIf there are 2 distinct contexts, one in which immutable type is always going to be the right way, and the other where we have mutable data, then having 2 separate types is imo OK. Alternatively, we could go SkBitmap route I think, they have the concept of `isImmutable()`/`setImmutable()` so that we can \"freeze\" the frame, then it\u0027d be a matter of enforcing it ourselves internally in the type I think.",
      "parentUuid": "7a98a817_3c897e7f",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a899e12_c24414a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1313149
      },
      "writtenOn": "2022-10-14T17:27:04Z",
      "side": 1,
      "message": "Response in thread.",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46b4a5c3_945915c1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1328910
      },
      "writtenOn": "2022-10-14T17:27:38Z",
      "side": 1,
      "message": "Can you help explain the cases where we end up with const/non-const frames and what it is that we need to do with both? Is it something where if it\u0027s const there\u0027s specific methods that may need to interact with it in a non-const way?\n\nIf it\u0027s better to set up a time to chat, that works too. Per my other comment; I\u0027m not sure if openscreen has any separate style guide; but it\u0027s worth noting that std::variant is banned in chromium code in favor of absl::variant; but that would probably still give you what you want?\n\nMy first instinct is that I think MutableEncodedFrame and ReadOnlyEncodedFrame *could* work and you\u0027d just put most of the logic into the base class and leave only the accessors in the child classes. It\u0027s sort of similar to having an \"is_mutable\" bool, but with a little bit more obvious of a construction pattern; though depending on how it gets plumbed around, you may violate some of the style rules about RTTI; but maybe you could sidestep that by having a \"GetMutableFrame\" method that just returns nullptr if it\u0027s the ReadOnly version.\n\nI\u0027ll take a look over the rest of the code now and see if that answers any of my other/earlier questions.",
      "parentUuid": "7a98a817_3c897e7f",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d0377fd9_a8367557",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-10-17T19:21:39Z",
      "side": 1,
      "message": "Thanks for the feedback. I think we can resolve the const-ness issues directly just by passing const where appropriate, and since std::variant is banned I need to give the backing bug some more thought.",
      "revId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:approval_code-owners"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "Submit requirement for the \u0027Verified\u0027 label"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:false"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:true"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:false"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:true"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "fb0c816d24e9da5c5b9e7d61d0dcc26354e7105d",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}