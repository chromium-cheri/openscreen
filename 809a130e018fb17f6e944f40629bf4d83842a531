{
  "comments": [
    {
      "key": {
        "uuid": "cce9ae88_1a69c9fe",
        "filename": "cast/common/channel/cast_socket.cc",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "Will a message that caused the socket to block be left in message_queue_?",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef51928b_700f4ccd",
        "filename": "cast/common/channel/cast_socket.cc",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "It\u0027s not clear what the design intention was (from the platform API interface code/comments). Based on an existing code review (https://chromium-review.googlesource.com/c/chromium/src/+/1867446), and outstanding comments from me, I\u0027m assuming all Write()\u0027s succeed, but it\u0027s invalid to call it after OnWriteBlocked() (and before OnWriteUnblocked()).\n\nWe may have to revisit this, depending on how things go in the other CL. This change is blocked on the other one anyway (to not clash the DEPS rolls). Thus, I\u0027ll take another look here once the other CL commits.\n\nI\u0027m also concerned about the \"flow control\" in the current design of the API, which we should probably revisit:\n\n1. TlsConnection::Write() has a void return type and is non-blocking, so it *has* to succeed.\n\n2. The OnWriteBlocked() callback is made asynchronously (according to platform/api comments), so we might call TlsConnection::Write() multiple times during one task, not having any *synchronous* feedback that writes have become blocked at some point and data is being discarded.\n\n3. The API is inconsistent with established industry norms for stream writes. We should rectify this to make it easier for embedder developers to adapt to their code.",
      "parentUuid": "cce9ae88_1a69c9fe",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38b60434_715474d7",
        "filename": "cast/common/channel/cast_socket.cc",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-08T00:13:35Z",
      "side": 1,
      "message": "My question was more specifically around if the loop at L78 exits because of a change to state_, should we include the last message attempted in the range of messages that are erased from message_queue_.\n\nMy reading is because of the post-increment, the current code will drop the message.  So we could increment after a write only if the state remains kOpen.",
      "parentUuid": "ef51928b_700f4ccd",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c28a206c_ae4a2b2c",
        "filename": "platform/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "I didn\u0027t see any uses from the platform API (nor should there be, as clients shouldn\u0027t need to know about our object management details.)\n\nCan this go into util/?",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7866de5_cf8c15d2",
        "filename": "platform/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "Good point. tl;dr: Moved to platform/impl/ instead.\n\nAt first, I did move it to util/. Then, I started working on your other comment about the thread-binding issue w.r.t. creates. Putting the two together, I\u0027m had to ask myself: Why is thread-aware code going in util/, when all of Open Screen is supposed to be single-threaded?\n\nI also chatted with Jordan a bit face-to-face, and we realized there actually isn\u0027t any need for this outside of the threaded networking code in platform/impl/. If we are to move this to util/, we can always do this later, after discussing team-wide the ramifications of \"blessing\" WeakPtrs for general usage.\n\nFWIW, we\u0027ve already successfully coded asynch callbacks throughout Open Screen without needing WeakPtrs so far. :)\n\nThus, I\u0027ve moved the weak pointer code to platform/impl/, to keep them isolated to just where they\u0027re used.",
      "parentUuid": "c28a206c_ae4a2b2c",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0598a45_7515d82b",
        "filename": "platform/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-08T00:13:35Z",
      "side": 1,
      "message": "That sounds good to me.  If we end up using it elsewhere, it should be simple to move it to util/.",
      "parentUuid": "c7866de5_cf8c15d2",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8ba977d7_7d29bb53",
        "filename": "platform/api/tls_connection.h",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "Nit: s/null/nullptr/",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c1e0c39_c611da7e",
        "filename": "platform/api/tls_connection.h",
        "patchSetId": 2
      },
      "lineNbr": 44,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8ba977d7_7d29bb53",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39e884ec_022ca8cb",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "nit: Open Screen\u0027s",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a7bda12_e4b52df3",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 20,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "39e884ec_022ca8cb",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d375f5e_f3d6e700",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-06T18:05:45Z",
      "side": 1,
      "message": "nit: Should the default ctor call into this?",
      "range": {
        "startLine": 95,
        "startChar": 0,
        "endLine": 95,
        "endChar": 28
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d7d48fa_5b0928ac",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "I\u0027d prefer not to force future readers of this code to have to jump to another ctor definition when the ctor body is trivial.",
      "parentUuid": "2d375f5e_f3d6e700",
      "range": {
        "startLine": 95,
        "startChar": 0,
        "endLine": 95,
        "endChar": 28
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c3d6ec0_0d100015",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-06T18:05:45Z",
      "side": 1,
      "message": "std::forward?\n\nHere and below",
      "range": {
        "startLine": 108,
        "startChar": 14,
        "endLine": 108,
        "endChar": 23
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bab45ff_0b2f574f",
        "filename": "platform/base/weak_ptr.h",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "There\u0027s an important difference. I found this helpful: https://isocpp.org/blog/2018/02/quick-q-whats-the-difference-between-stdmove-and-stdforward\n\nFWIW, the code also doesn\u0027t compile, when using std::forward.",
      "parentUuid": "6c3d6ec0_0d100015",
      "range": {
        "startLine": 108,
        "startChar": 14,
        "endLine": 108,
        "endChar": 23
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f67877d6_d6bc3b7e",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "Since OnConnected is getting a raw (not a weak pointer), what assumptions can client_ make about the lifetime of the |self| that\u0027s being passed into it?\n\nSimilar comment applies to other uses of this pattern here.",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4639749c_3bffb3da",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "My understanding is that, from the client\u0027s perspective, |self| should be a valid pointer during the OnConnected() method call. I\u0027m not sure why TlsConnectionFactory* was included in the Client::OnConnected() API. Maybe it is meant to identify which TCFactory instance is calling int o the Client? But, why wouldn\u0027t the code that set the TCFactory\u0027s Client already know that; and, how many different instances of TCFactory are floating around in the program? I wasn\u0027t involved in the discussion here.\n\nBased on this, and other comments/replies, it sounds like we might want to revisit some of the API decisions...",
      "parentUuid": "f67877d6_d6bc3b7e",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a743dfc_36a057c4",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 91,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-08T00:13:35Z",
      "side": 1,
      "message": "Ok, it would be safer not to pass self as all, as if OnConnected decides to delete it then Bad Things will happen.  Let\u0027s see if we can reduce the amount of |this|-passing and replace the necessary uses with safer patterns (shared_ or weak_ ptrs).",
      "parentUuid": "4639749c_3bffb3da",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "caca0211_6be4e358",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-06T18:05:45Z",
      "side": 1,
      "message": "Why this change in logic?\n\nWith the previous approach: This method posts a task to the task runner to:\n1) Accept the new connection (if it wasn\u0027t already accepted previously - because threading)\n2) Calls OnSocketAccepted(...) on the new connection\n\nThe processing then is done on the task runner when this task is popped, not when this method is initially called, so the caller doesn\u0027t need to worry about blocking the thread\n\nBased on my most recent reading of the documentation (http://man7.org/linux/man-pages/man2/select.2.html), it sounds like we should be using PSELECT rather than SELECT to ensure thread safety, but if we do that it sounds like parallel calls to SELECT and ACCEPT (which I assume was your concern with the previous approach) should be a non-issue",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 137,
        "endChar": 3
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "776ed7de_b2c2b239",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "The old code attempted to use the raw |socket| pointer in the task, but it may have become invalid by the time that task was run and would call socket-\u003eAccept().\n\nI realized that the caller was holding a lock that would guarantee the socket remains alive (including its POSIX file descriptor) while calling Accept() here. I wasn\u0027t worried about which thread calls accept() because POSIX sockets are guaranteed by the standard to be thread-safe. That, and I don\u0027t think there\u0027s a race here, since accept() is all about \"instantiating\" a new socket that will live on its own, detached from the server socket that had spawned it.",
      "parentUuid": "caca0211_6be4e358",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 137,
        "endChar": 3
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e393881_d5c9ed38",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-08T00:20:10Z",
      "side": 1,
      "message": "The reason for the extra level of indirection was to ensure that the the socket was created on the TaskRunner thread to avoid the data races mentioned in the header file - we don\u0027t currently support blocking the TaskRunner, and adding that method to the TaskRunner would complicate the public API\n\nCould we create a new WeakPtrFactory in the StreamSocket and pass that instead of the raw pointer? That way, we avoid the bug called out in the header without any added complexity",
      "parentUuid": "776ed7de_b2c2b239",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 137,
        "endChar": 3
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97abc12d_8375e338",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 142,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-05T23:34:33Z",
      "side": 1,
      "message": "It looks like you\u0027re creating a WeakPtr on one thread and passing it to another.\n\nIn Chromium, weak_ptr\u0027s aren\u0027t threadsafe; the factory that vends them is bound to one thread (or sequence).  Is the std:: equivalent different?",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26c9ffa6_9bddf415",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 142,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "Good catch. I reviewed Chromium\u0027s WeakPtr again. I had it mostly correct: They are thread-safe when copying/moving around between threads. What I didn\u0027t realize is the *first* WeakPtr created by the factory binds it to the thread.\n\nSo, std::shared_ptr\u003c\u003e and std::weak_ptr\u003c\u003e are thread-safe in the way we\u0027re using them here (for their bookkeeping). It means that creating WeakPtrs *can* be created on any thread without any logic flaws, invalid pointer dereferencing, etc.\n\nGiven the convenience and safety (and since we\u0027re using these only in platform/impl/ code), I think it\u0027s reasonable to allow this deviation from Chromium\u0027s bind-when-create behavior. I\u0027ve updated the usage/top-level \"thread-safety\" comments in weak_ptr.h to discuss the behavior.",
      "parentUuid": "97abc12d_8375e338",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70b9a23a_45292216",
        "filename": "platform/impl/tls_connection_factory_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 142,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-11-08T00:13:35Z",
      "side": 1,
      "message": "Sounds good, see the comments I left there.",
      "parentUuid": "26c9ffa6_9bddf415",
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35ad11fe_1252d11a",
        "filename": "platform/impl/tls_connection_factory_posix.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-06T18:05:45Z",
      "side": 1,
      "message": "Wouldn\u0027t different connections have different ports (so different IPEndpoints)?",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 34,
        "endChar": 63
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0eec65a7_73d10507",
        "filename": "platform/impl/tls_connection_factory_posix.h",
        "patchSetId": 2
      },
      "lineNbr": 34,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "This comment was moved from the platform/api/tls_connection.h. I don\u0027t understand the context behind it, but I moved it to here because it seemed like an implementation detail.",
      "parentUuid": "35ad11fe_1252d11a",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 34,
        "endChar": 63
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed0d88ee_d7383624",
        "filename": "platform/impl/tls_connection_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 143,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-06T18:05:45Z",
      "side": 1,
      "message": "These should be called on the TaskRunner thread (same pattern used above). Same for below calls\n\nIMHO the code is more readable with these as separate functions than written inline, but I don\u0027t have a strong opinion either way",
      "range": {
        "startLine": 143,
        "startChar": 6,
        "endLine": 143,
        "endChar": 36
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ede3ec19_c7644c4f",
        "filename": "platform/impl/tls_connection_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 143,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-11-07T02:54:08Z",
      "side": 1,
      "message": "\u003e These should be called on the TaskRunner thread (same pattern used above).\n\nThey are. Note the DCHECK on L138.\n\nThey also cannot be called in a separate task: If we do that, a client may call Write() multiple times, and never know that a socket has become blocked at some point. The TlsWriteBuffer will silently discard bytes at that point, but that\u0027s not acceptable because TLS connections are supposed to guarantee delivery of all bytes that are written.\n\n\u003e IMHO the code is more readable with these as separate functions than written inline...\n\nThe problem is that those functions were declared in the interface class. I could move them into this impl class, but when I did a very similar thing for UdpSocketPosix, the code review discussion evolved into, \"Keep it simple and call into the client directly since this is the only place method Client::XYZ() is being called..\"",
      "parentUuid": "ed0d88ee_d7383624",
      "range": {
        "startLine": 143,
        "startChar": 6,
        "endLine": 143,
        "endChar": 36
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f744cd32_78a9fdb8",
        "filename": "platform/impl/tls_connection_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 143,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-11-08T00:20:10Z",
      "side": 1,
      "message": "\u003e They also cannot be called in a separate task: If we do that, a client may call Write() multiple times, and never know that a socket has become blocked at some point. The TlsWriteBuffer will silently discard bytes at that point, but that\u0027s not acceptable because TLS connections are supposed to guarantee delivery of all bytes that are written.\n\nActually, that\u0027s not true\n\nOnWriteBlocked(...) gets signaled when we hit about 1/2 buffer capacity to solve exactly this problem. We keep queueing up bytes until we hit 100% capacity, at which point we signal OnError(...) which is a fatal error for the TLS connection, and the connection is killed off. Bytes are never discarded. As long as the caller hasn\u0027t queued up 1/2 MB of data in the TaskRunner after we signal OnWriteBlocked (which should never happen over our TLS channel), this error case shouldn\u0027t ever happen - especially since the TLS Write data is pulled out in what-is-essentially-a-hot-loop on the networking thread\n\nBy design, NotifyWriteBufferFill(...) must be callable from any thread. In TlsDataWriteBuffer, this method is called both from Write (TaskRunner Thread) and Consume (Networking thread) - this was our Lockless FIFO :) So the OSP_CHECK approach doesn\u0027t work",
      "parentUuid": "ede3ec19_c7644c4f",
      "range": {
        "startLine": 143,
        "startChar": 6,
        "endLine": 143,
        "endChar": 36
      },
      "revId": "809a130e018fb17f6e944f40629bf4d83842a531",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}