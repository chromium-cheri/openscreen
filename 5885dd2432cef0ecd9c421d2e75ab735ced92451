{
  "comments": [
    {
      "key": {
        "uuid": "1d1ce722_966c30f1",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 8,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2018-09-21T23:50:00Z",
      "side": 1,
      "message": "Did you mean to use DISALLOW_COPY_AND_ASSIGN below?  If not, this can be removed.",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88f1911c_232a251a",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 8,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2018-09-24T18:06:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1d1ce722_966c30f1",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9ad4a94_e75e5a53",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2018-09-21T23:50:00Z",
      "side": 1,
      "message": "pair is redundant/erroneous here.",
      "range": {
        "startLine": 42,
        "startChar": 56,
        "endLine": 42,
        "endChar": 60
      },
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8086182c_ec262ba5",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2018-09-24T18:06:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d9ad4a94_e75e5a53",
      "range": {
        "startLine": 42,
        "startChar": 56,
        "endLine": 42,
        "endChar": 60
      },
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "36f0cdc0_913acd7b",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 49,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2018-09-21T23:50:00Z",
      "side": 1,
      "message": "Looking at the API here and considering previous comments about sharing the underlying QUIC connection, is the expectation that there is always an existing ScreenConnection for a given receiver (advertised via OnConnectionAdded) even without any Presentation API calls being made?  So ScreenConnectionClient::Start() just opens QUIC connections to every discovered device?",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34d6cf91_261cc427",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 49,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2018-09-22T00:20:06Z",
      "side": 1,
      "message": "No, I don\u0027t think we\u0027d want to open QUIC connections to every discovered device.  That doesn\u0027t scale to many devices on the network.  Plus, it would require the whole JPAKE password thing in many cases.\n\nI was thing it\u0027s more like an \"on demand\" thing.  When you need to, you create one.  The first time, you might also need to be prepared to put in a JPAKE password.  Future times, you could do it ahead of time if you anticipated an action and wanted more speed (say... there\u0027s only 1 device in the list and you expect the user will click on it).  \n\nBut we shouldn\u0027t consider setting up a connection so cheap as to make them like crazy.",
      "parentUuid": "36f0cdc0_913acd7b",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c7c6dfa_875e226a",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 49,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2018-09-22T00:29:38Z",
      "side": 1,
      "message": "Agreed.  What is the control flow then for getting a connection without first issuing an OSP control message?  There doesn\u0027t seem to be such an API in this patch.  Is that going to be dependent on our future integration of J-PAKE?",
      "parentUuid": "34d6cf91_261cc427",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c635988_925f18d1",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 49,
      "author": {
        "id": 1271529
      },
      "writtenOn": "2018-09-22T00:33:37Z",
      "side": 1,
      "message": "I guess that will come in future patches, but I\u0027m guessing as a server, you would specify the password, then it would run you\u0027d get a callback once QUIC+JPAKE has been done.  As a client, you would specify which of the discovered devices and provide a JPAKE password if necessary and then get back a connection immediately, but it wouldn\u0027t be running until QUIC+JPAKE was complete.",
      "parentUuid": "6c7c6dfa_875e226a",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d1fa46b_e8704feb",
        "filename": "api/public/screen_connection.h",
        "patchSetId": 6
      },
      "lineNbr": 49,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2018-09-24T18:06:02Z",
      "side": 1,
      "message": "The question for this patch is: do we want the embedder to be able to force the library to connect on demand, or is that up to the implementation of individual protocols.  My opinion is to go with the latter initially until there is a use case for the former.\n\nRegarding J-PAKE, the rough flow I had in mind is:\n\n(1) Expose a status flag on the screen_info with authentication state.\n(2) Before an embedder can OSP to an unauthenticated screen, they have to authenticate through a separate embedder API specifically for authentication.  This creates a connection behind the scenes, but only for J-PAKE.  The embedder will need to be part of the J-PAKE flow).\n(3) Once the connection becomes authenticatied, it is exposed as a full-fledged ProtocolConnection and then they can use regular OSP or custom protocols.",
      "parentUuid": "0c635988_925f18d1",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86ec4083_2cf3b799",
        "filename": "api/public/screen_connection_client.h",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2018-09-21T23:50:00Z",
      "side": 1,
      "message": "Looking at the server patch, this needs a base because only the server can suspend, and they have different error and metrics types (which actually hold the same data).  Although it probably makes less sense to suspend the connection client, is there any reason we couldn\u0027t?  I suppose it\u0027s not really a problem, but the client and server seem so similar, I wonder if they could just be the same type (ScreenConnectionEndpoint?), with something like a \"should_listen\" flag.  For that matter, I suppose that could just be how they are implemented, even though the interfaces are separate.  It feels hard to say without any implementation above _or_ below.",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ce23bc8_2eb98b24",
        "filename": "api/public/screen_connection_client.h",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2018-09-24T18:06:02Z",
      "side": 1,
      "message": "Regarding the suspend question, there are two use cases for suspending network services like this:\n\n1/The upstream clients in the embedder are all inactive/backgrounded (i.e., your tab went in the background), but they could become active at any time.\n2/The embedder went into a low power state but could come back at any time (you closed the lid on your laptop).\n\nIn either case, OSP shouldn\u0027t run an event loop and handle packets to save power. Ideally, we don\u0027t want to close all the sockets and drop connection state either so we can resume quickly.  The question is, will the connections remain in a useful state?\n\nRegarding the typing, looking at the demo code for QUIC, the implementations are different, so I am inclined to keep separate types for now.  If we discover at the end that the embedder APIs are identical, I don\u0027t see any obstacle to extracting a common type later before we finalize the embedder public APIs.\n\nAdded notes here capturing some of this discussion.  Let me know if you think code changes are needed.",
      "parentUuid": "86ec4083_2cf3b799",
      "revId": "5885dd2432cef0ecd9c421d2e75ab735ced92451",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}