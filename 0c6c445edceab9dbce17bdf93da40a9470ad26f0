{
  "comments": [
    {
      "key": {
        "uuid": "5c4ab726_8b45768c",
        "filename": "cast/common/public/service_info.cc",
        "patchSetId": 5
      },
      "lineNbr": 190,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2020-03-10T21:09:03Z",
      "side": 1,
      "message": "What does it mean to have an instance record without an IPv4/IPv6 address?",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ca971f4a_d555bee5",
        "filename": "cast/common/public/service_info.cc",
        "patchSetId": 5
      },
      "lineNbr": 190,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-10T23:59:42Z",
      "side": 1,
      "message": "An InstanceRecord, per our previous discussions, is just what a service publishes to ALL network interfaces, not a single one (Which is where the IP would come in). At the embedder layer, the IP address isn\u0027t known (instead, the config just provides an InterfaceInfo), and combining these two is the job of the DNS-SD layer\u0027s implementation\n\nThe port is shared by all network interfaces, so it can be included here",
      "parentUuid": "5c4ab726_8b45768c",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd30018a_314ddf7e",
        "filename": "cast/common/public/service_info.cc",
        "patchSetId": 5
      },
      "lineNbr": 190,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-27T23:11:38Z",
      "side": 1,
      "message": "I\u0027ve split the port into a separate field as part of a parallel CL to make this clearer (and rebased this one on top). Also, I\u0027ve added comments",
      "parentUuid": "ca971f4a_d555bee5",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c8d2d49_ca81b89f",
        "filename": "discovery/common/config.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2020-03-10T21:09:03Z",
      "side": 1,
      "message": "Style nit: since there are three legal states, an enum would be ideal.",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e19b2551_e8092dc2",
        "filename": "discovery/common/config.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-27T23:11:38Z",
      "side": 1,
      "message": "Done\n\nPulled the existing MdnsService enum up a level to here :)",
      "parentUuid": "7c8d2d49_ca81b89f",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "57fabf22_eda45b1b",
        "filename": "discovery/dnssd/impl/network_config.h",
        "patchSetId": 5
      },
      "lineNbr": 14,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2020-03-10T21:09:03Z",
      "side": 1,
      "message": "How is this different from Config::NetworkConfig?",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46fd2f67_97905619",
        "filename": "discovery/dnssd/impl/network_config.h",
        "patchSetId": 5
      },
      "lineNbr": 14,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-10T23:59:42Z",
      "side": 1,
      "message": "This limits the scope of the data that the DNS-SD layer has access to:\n- The InterfaceInfo has a lot more data than just the IP Addresses and network interface\n- Some of this information would need to be repeatedly combined and DCHECK\u0027d (ie - whether an IP family is supported vs if one is available). This centralized that logic to DnsSdServiceImpl - since we will later have one of these per Network Interface",
      "parentUuid": "57fabf22_eda45b1b",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da0e788c_0a3c39bb",
        "filename": "discovery/dnssd/impl/publisher_impl.cc",
        "patchSetId": 5
      },
      "lineNbr": 60,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-24T21:49:27Z",
      "side": 1,
      "message": "These functions look very similar to me. Could you please have another look if you can minimize code duplication here?",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 60,
        "endChar": 1
      },
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78f97978_43575a50",
        "filename": "discovery/dnssd/impl/publisher_impl.cc",
        "patchSetId": 5
      },
      "lineNbr": 60,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-27T23:11:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "da0e788c_0a3c39bb",
      "range": {
        "startLine": 24,
        "startChar": 0,
        "endLine": 60,
        "endChar": 1
      },
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7cc3f9ba_50008b7f",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2020-03-10T21:09:03Z",
      "side": 1,
      "message": "I see some pros to splitting this type up, but it adds complexity, and you wont be able to add addresses to an existing instance record without making a copy.  At first glance, this doesn\u0027t feel like an \"is-a\" relationship.\n\nWhat about just making the addresses optional in DnsSdInstanceRecord?\n\nWill instance records without IP addresses ever be exposed to the DNS-SD layer?  ISTM that as soon as the DNS records are received from an interface, the mDNS layer can pass the IP addresss of that interface up to the DNS-SD layer.",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21f81e39_379a125e",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-10T23:59:42Z",
      "side": 1,
      "message": "I am happy to defer to your and Max\u0027s decision, but some of my thoughts\n\n\u003e I see some pros to splitting this type up, but it adds complexity, and you wont be able to add addresses to an existing instance record without making a copy.\n\nIf the issue is a copy, I can add a ctor taking a DnsSdInstanceRecord\u0026\u0026 and move all the data out, to avoid all copied\n\n\u003e Will instance records without IP addresses ever be exposed to the DNS-SD layer\n\nI actually avoided this question when considering the design - the DNS-SD layer is just our implementation of a public API, which the embedder can implement any way they choose\n\n\u003e What about just making the addresses optional in DnsSdInstanceRecord?\n\nI can go this route if you prefer, but IMHO this is harder for the embedder to understand than using sepeate objects - To me, it feels like an \"is-a\" relationship, with \"specific network interface endpoint of a chromecast service hosted by a device\" is a  \"chromecast service hosted by a device\"",
      "parentUuid": "7cc3f9ba_50008b7f",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb9be300_1552f0ed",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-11T18:31:55Z",
      "side": 1,
      "message": "\u003e Will instance records without IP addresses ever be exposed to the DNS-SD layer\n\nTo further expand here, they are exposed in the public API. These are what the publisher takes in, and it is the responsibility of the embedder\u0027s impl of this public API to handle combining it with the config. The idea here is that the embedder is telling the service \"Here is a service I\u0027m hosting - you go figure out how to combine that with the network interfaces I support, and fan this publication out to all of these network interfaces\".\n\nInstead if we provide a DnsSdInstanceEndpoint as you mention, IMHO it feels like \"Here is a service instance I am hosting. If the endpoints are populated, you do whatever you think is right\" because this is the embedder-specific implementation \" and maybe publish just that endpoint, maybe error if it doesn\u0027t match an existing NetworkInterface, maybe fan out to all interfaces, but who knows because the public API doesn\u0027t force any behavior!\". While we could document expected behavior, it feels MUCH cleaner to me to not give embedders this kind of freedom. Especially if such edge cases will only pop up occasionally. While it\u0027s correct that it\u0027s the embedder\u0027s fault for implementing things wrong if they don\u0027t follow what we recommend in the dndds/public dir it would be their fault, that doesn\u0027t stop it from reflecting badly on us since it\u0027s our library they are using. Or from us receiving bug reports",
      "parentUuid": "21f81e39_379a125e",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20d46494_3e68aabc",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-24T21:49:27Z",
      "side": 1,
      "message": "I think this is in general a correct use of inheritance. DnsSdInstanceEndpoint is a DnsSdInstanceRecord + address(es).\nI wonder if aggregation instead of inheritance would be more compact code-wise, since this is essentially a data structure with minimal logic.\nIMHO optional fields add to complexity all the same, with code having to check everywhere if optional has a value.",
      "parentUuid": "eb9be300_1552f0ed",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8cf5f02f_a0a52d91",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-24T22:34:33Z",
      "side": 1,
      "message": "@mfoltz, WDYT? If you agree, would you prefer aggregation or inheritance - I\u0027m happy to go either route, just want to reach consensus before making any code changes\n\nIMHO inheritance is more compact - there are places in the updated code where we make use of DnsSdInstanceEndpoint is a DnsSdInstanceRecord to simplify calls into methods that require a DnsSdInstanceRecord\n\nAlso, WDYT about the current names vs the ones suggested in the thread below?",
      "parentUuid": "20d46494_3e68aabc",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a89edab_d8f3e1ad",
        "filename": "discovery/dnssd/public/dns_sd_instance_endpoint.h",
        "patchSetId": 5
      },
      "lineNbr": 19,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-27T23:11:38Z",
      "side": 1,
      "message": "For now, I will proceed with inheritance and address all other comments. If either of you would like me to change to aggregation or would like names changed, I will address it as those comments come up",
      "parentUuid": "8cf5f02f_a0a52d91",
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7f0cc116_5b9945a4",
        "filename": "discovery/public/dns_sd_service_watcher.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-24T21:49:27Z",
      "side": 1,
      "message": "I know that std does not provide a function for combining hash values, which is quite unfortunate. However, XOR for hash values is not a safe strategy for collision avoidance.\n\nYou can see a way to combine hashes in ComputeDomainNameSubhashes in mdsn_writer. Or you can use absl::hash instead of EndpointKeyHash, absl::hash supports all std types that have std::hash specialized for them and it has automatic hash combining for pairs and tuples.\n\nAlso, I was under impression that std::hash works for pairs and tuples automatically if they consist of hashable types, but I guess I\u0027m wrong on this.",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 134,
        "endChar": 60
      },
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2c866fa_9c93c55e",
        "filename": "discovery/public/dns_sd_service_watcher.h",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-03-27T23:11:38Z",
      "side": 1,
      "message": "\u003e You can see a way to combine hashes in ComputeDomainNameSubhashes in mdsn_writer\n\nDone. Put up a parallel CL to split this logic into a separate file and rebasing this CL on top of it\n\n\u003e Or you can use absl::hash instead of EndpointKeyHash\n\nUnfortunately because this is embedder-exposed, abseil can\u0027t be used. \n\n\u003e Also, I was under impression that std::hash works for pairs and tuples automatically if they consist of hashable types\n\nValidated again to confirm that this is needed. Unfortunately it is",
      "parentUuid": "7f0cc116_5b9945a4",
      "range": {
        "startLine": 133,
        "startChar": 13,
        "endLine": 134,
        "endChar": 60
      },
      "revId": "0c6c445edceab9dbce17bdf93da40a9470ad26f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}