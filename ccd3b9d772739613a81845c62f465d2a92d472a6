{
  "comments": [
    {
      "key": {
        "uuid": "cabfb6a4_faa7ecee",
        "filename": "osp_base/alarm.cc",
        "patchSetId": 3
      },
      "lineNbr": 71,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "It might be good to note that queued_fire_ will be nullptr after Cancel() returns.",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bec279d2_91804662",
        "filename": "osp_base/alarm.cc",
        "patchSetId": 3
      },
      "lineNbr": 71,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cabfb6a4_faa7ecee",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3bbdac2_1940880c",
        "filename": "osp_base/alarm.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "Is it expected that task_runner_ will be bound to a different thread than the one that instantiated the Alarm and scheduled the tasks?  Is it safe to access Alarm members in that scenario?",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1879c91_3591a84b",
        "filename": "osp_base/alarm.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "All the usual OpenScreen sequential task runner restrictions still apply. So, there should be no concurrency concerns.",
      "parentUuid": "a3bbdac2_1940880c",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef0d24e5_def8196d",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "nit: s/If/if/",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "689d31ba_00cd52e0",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ef0d24e5_def8196d",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4180cf0_103e9e35",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "nit: callback",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a928217e_064cea69",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f4180cf0_103e9e35",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "404b6a2e_fecc3b42",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "Perhaps note that functor should be move-able.  I don\u0027t believe that callers will want the Alarm to copy functor, but I could be wrong.  For bonus points, have this function take Functor\u0026\u0026.",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b146f9de_ede958fd",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-18T22:20:40Z",
      "side": 1,
      "message": "Functor\u0026\u0026 doesn\u0027t guarantee it\u0027s an r-value ref since Functor is a template parameter.",
      "parentUuid": "404b6a2e_fecc3b42",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f64bd2b2_2d0d6ecd",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "I think it\u0027s okay in many common situations if the functor argument is copied: For example, there could be cases where it may be nothing more than a raw function pointer, or an object consisting of nothing more than a method pointer paired with a raw \"this\" pointer.\n\nFor more complex use cases, I agree with you that we should encourage use of std::move() in calling code. However, rather than make the argument Functor\u0026\u0026, we can enforce the use of move-only in this situation by making sure the objects to be bound are defined as move-only. Then, when they are bound, say, with std::bind(), the result can only be a move-only functor. With this, calls like this will compile successfully:\n\n  Schedule(std::bind(\u0026Foo::DoIt, std::move(move_only_thing)), exec_time);\n  // OK: std::bind() returns a non-copyable, move-only functor, which\n  // is exactly what we want. :)\n\n...but calls like this (that would copy-construct) will be rejected:\n\n  Schedule(std::bind(\u0026Foo::DoIt, move_only_thing)), exec_time);\n  // COMPILE ERROR: Cannot call std::bind() because there\u0027s no copy\n  // ctor for move_only_thing.",
      "parentUuid": "b146f9de_ede958fd",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6bceb97_f322fedd",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-19T19:30:18Z",
      "side": 1,
      "message": "OK, but allowing copy-able callbacks punts the issue to the correct usage of std::bind, which is banned in Chromium.\n\nhttps://groups.google.com/a/chromium.org/forum/#!topic/cxx/SoEj7oIDNuA\n\nWe could write our own bind wrapper that generates move-only callbacks and checks its arguments.",
      "parentUuid": "f64bd2b2_2d0d6ecd",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ada1f94_73376b9e",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "What if the Task is currently executing, or has already executed?",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fbc8e2e8_1ae01989",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "The assumption is a single-threaded/sequential task runner. So, the only possible case is re-entrancy (i.e., a scheduled task runs which itself calls Schedule() again). That\u0027s documented in the class-level comments, and the impl explicitly addresses this in Alarm::TryInvoke().",
      "parentUuid": "4ada1f94_73376b9e",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3794507_2256e5e4",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-19T19:30:18Z",
      "side": 1,
      "message": "So the assumption is that the this class is used only from the same thread that is bound to task_runner; please make that explicit in the class-level comments.",
      "parentUuid": "fbc8e2e8_1ae01989",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cebae2f_919c3e68",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 54,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "What if the task is currently executing?",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "211c5a95_f8f38c71",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 54,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "Re-entrant calls are fine, accounted for (see my response to your last comment).",
      "parentUuid": "7cebae2f_919c3e68",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4a5218e_8cc834ea",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-06-18T22:16:15Z",
      "side": 1,
      "message": "Task\u0026\u0026?\n\nNit: I think names shortened by using-expressions are discouraged in public APIs, but I\u0027m not sure if this is spelled out or enforced.  I don\u0027t feel that strongly about it in a small codebase like OSP.",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d739423_9caf8169",
        "filename": "osp_base/alarm.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-19T00:34:14Z",
      "side": 1,
      "message": "Done. Removed the name-shortener since it didn\u0027t significantly impact many LOC, formatting, etc.",
      "parentUuid": "f4a5218e_8cc834ea",
      "revId": "ccd3b9d772739613a81845c62f465d2a92d472a6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}