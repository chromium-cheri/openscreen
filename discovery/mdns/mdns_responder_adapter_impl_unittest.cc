// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <memory>
#include <string>

#include "discovery/mdns/mdns_responder_adapter_impl.h"
#include "third_party/googletest/src/googlemock/include/gmock/gmock.h"
#include "third_party/googletest/src/googletest/include/gtest/gtest.h"

namespace openscreen {
namespace {

using ::testing::ElementsAre;
using ::testing::ElementsAreArray;

// Example response for _googlecast._tcp.  Contains PTR, SRV, TXT, A records.
uint8_t data[] = {
    0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03,
    0x0b, 0x5f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x63, 0x61, 0x73, 0x74,
    0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
    0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x34, 0x31, 0x43,
    0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61, 0x73, 0x74, 0x2d, 0x55, 0x6c,
    0x74, 0x72, 0x61, 0x2d, 0x63, 0x34, 0x64, 0x37, 0x63, 0x39, 0x39, 0x34,
    0x33, 0x39, 0x31, 0x36, 0x65, 0x31, 0x36, 0x65, 0x37, 0x34, 0x62, 0x64,
    0x39, 0x66, 0x32, 0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35, 0x65, 0x63,
    0xc0, 0x0c, 0xc0, 0x2e, 0x00, 0x10, 0x80, 0x01, 0x00, 0x00, 0x11, 0x94,
    0x00, 0xb4, 0x23, 0x69, 0x64, 0x3d, 0x63, 0x34, 0x64, 0x37, 0x63, 0x39,
    0x39, 0x34, 0x33, 0x39, 0x31, 0x36, 0x65, 0x31, 0x36, 0x65, 0x37, 0x34,
    0x62, 0x64, 0x39, 0x66, 0x32, 0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35,
    0x65, 0x63, 0x23, 0x63, 0x64, 0x3d, 0x31, 0x36, 0x34, 0x46, 0x33, 0x42,
    0x31, 0x36, 0x46, 0x36, 0x41, 0x44, 0x44, 0x43, 0x32, 0x45, 0x39, 0x46,
    0x41, 0x30, 0x31, 0x45, 0x34, 0x41, 0x38, 0x31, 0x37, 0x45, 0x38, 0x37,
    0x35, 0x34, 0x03, 0x72, 0x6d, 0x3d, 0x05, 0x76, 0x65, 0x3d, 0x30, 0x35,
    0x13, 0x6d, 0x64, 0x3d, 0x43, 0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61,
    0x73, 0x74, 0x20, 0x55, 0x6c, 0x74, 0x72, 0x61, 0x12, 0x69, 0x63, 0x3d,
    0x2f, 0x73, 0x65, 0x74, 0x75, 0x70, 0x2f, 0x69, 0x63, 0x6f, 0x6e, 0x2e,
    0x70, 0x6e, 0x67, 0x13, 0x66, 0x6e, 0x3d, 0x44, 0x42, 0x42, 0x20, 0x43,
    0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61, 0x73, 0x74, 0x20, 0x4c, 0x08,
    0x63, 0x61, 0x3d, 0x31, 0x32, 0x32, 0x39, 0x33, 0x04, 0x73, 0x74, 0x3d,
    0x30, 0x0f, 0x62, 0x73, 0x3d, 0x46, 0x41, 0x38, 0x46, 0x43, 0x41, 0x37,
    0x38, 0x33, 0x38, 0x38, 0x35, 0x04, 0x6e, 0x66, 0x3d, 0x31, 0x03, 0x72,
    0x73, 0x3d, 0xc0, 0x2e, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78,
    0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x49, 0x24, 0x63, 0x34, 0x64,
    0x37, 0x63, 0x39, 0x39, 0x34, 0x2d, 0x33, 0x39, 0x31, 0x36, 0x2d, 0x65,
    0x31, 0x36, 0x65, 0x2d, 0x37, 0x34, 0x62, 0x64, 0x2d, 0x39, 0x66, 0x32,
    0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35, 0x65, 0x63, 0xc0, 0x1d, 0xc1,
    0x34, 0x00, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x04, 0xac,
    0x11, 0x20, 0x8a,
};

const mdns::DomainName googlecast_service{
    {11, '_', 'g', 'o', 'o', 'g', 'l', 'e', 'c', 'a', 's', 't',
     4,  '_', 't', 'c', 'p', 5,   'l', 'o', 'c', 'a', 'l', 0}};
const IPv4Endpoint mdns_endpoint{{224, 0, 0, 251}, 5353};

}  // namespace

TEST(MdnsResponderAdapterImplTest, ExampleData) {
  auto mdns_adapter = std::unique_ptr<mdns::MdnsResponderAdapter>(
      new mdns::MdnsResponderAdapterImpl);
  mdns_adapter->Init();
  mdns_adapter->StartPtrQuery(googlecast_service);
  mdns_adapter->OnDataReceived({{192, 168, 0, 2}, 12345}, mdns_endpoint, data,
                               sizeof(data), 0);
  mdns_adapter->Execute();

  auto ptr = mdns_adapter->TakePtrResponses();
  ASSERT_EQ(1u, ptr.size());
  ASSERT_THAT(ptr[0].service_instance.GetLabels(),
              ElementsAre("Chromecast-Ultra-c4d7c9943916e16e74bd9f2e2eabe5ec",
                          "_googlecast", "_tcp", "local"));
  mdns_adapter->StartSrvQuery(ptr[0].service_instance);
  mdns_adapter->StartTxtQuery(ptr[0].service_instance);
  mdns_adapter->Execute();

  auto srv = mdns_adapter->TakeSrvResponses();
  ASSERT_EQ(1u, srv.size());
  ASSERT_THAT(srv[0].domain_name.GetLabels(),
              ElementsAre("c4d7c994-3916-e16e-74bd-9f2e2eabe5ec", "local"));
  EXPECT_EQ(8009, srv[0].port);

  auto txt = mdns_adapter->TakeTxtResponses();
  ASSERT_EQ(1u, txt.size());
  const std::string expected_txt[] = {"id=c4d7c9943916e16e74bd9f2e2eabe5ec",
                                      "cd=164F3B16F6ADDC2E9FA01E4A817E8754",
                                      "rm=",
                                      "ve=05",
                                      "md=Chromecast Ultra",
                                      "ic=/setup/icon.png",
                                      "fn=DBB Chromecast L",
                                      "ca=12293",
                                      "st=0",
                                      "bs=FA8FCA783885",
                                      "nf=1",
                                      "rs="};
  EXPECT_THAT(txt[0].txt_info, ElementsAreArray(expected_txt));

  mdns_adapter->StartAQuery(srv[0].domain_name);
  mdns_adapter->Execute();

  auto a = mdns_adapter->TakeAResponses();
  ASSERT_EQ(1u, a.size());
  EXPECT_EQ((IPv4Address{172, 17, 32, 138}), a[0].address);

  mdns_adapter->Close();
}

}  // namespace openscreen
