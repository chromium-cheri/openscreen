// Copyright 2018 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <memory>
#include <string>

#include "discovery/mdns/mdns_responder_adapter_impl.h"
#include "platform/api/logging.h"

namespace openscreen {
namespace {

// Example response for _googlecast._tcp.  Contains PTR, SRV, TXT, A records.
uint8_t data[] = {
    0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03,
    0x0b, 0x5f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x63, 0x61, 0x73, 0x74,
    0x04, 0x5f, 0x74, 0x63, 0x70, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
    0x00, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x34, 0x31, 0x43,
    0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61, 0x73, 0x74, 0x2d, 0x55, 0x6c,
    0x74, 0x72, 0x61, 0x2d, 0x63, 0x34, 0x64, 0x37, 0x63, 0x39, 0x39, 0x34,
    0x33, 0x39, 0x31, 0x36, 0x65, 0x31, 0x36, 0x65, 0x37, 0x34, 0x62, 0x64,
    0x39, 0x66, 0x32, 0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35, 0x65, 0x63,
    0xc0, 0x0c, 0xc0, 0x2e, 0x00, 0x10, 0x80, 0x01, 0x00, 0x00, 0x11, 0x94,
    0x00, 0xb4, 0x23, 0x69, 0x64, 0x3d, 0x63, 0x34, 0x64, 0x37, 0x63, 0x39,
    0x39, 0x34, 0x33, 0x39, 0x31, 0x36, 0x65, 0x31, 0x36, 0x65, 0x37, 0x34,
    0x62, 0x64, 0x39, 0x66, 0x32, 0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35,
    0x65, 0x63, 0x23, 0x63, 0x64, 0x3d, 0x31, 0x36, 0x34, 0x46, 0x33, 0x42,
    0x31, 0x36, 0x46, 0x36, 0x41, 0x44, 0x44, 0x43, 0x32, 0x45, 0x39, 0x46,
    0x41, 0x30, 0x31, 0x45, 0x34, 0x41, 0x38, 0x31, 0x37, 0x45, 0x38, 0x37,
    0x35, 0x34, 0x03, 0x72, 0x6d, 0x3d, 0x05, 0x76, 0x65, 0x3d, 0x30, 0x35,
    0x13, 0x6d, 0x64, 0x3d, 0x43, 0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61,
    0x73, 0x74, 0x20, 0x55, 0x6c, 0x74, 0x72, 0x61, 0x12, 0x69, 0x63, 0x3d,
    0x2f, 0x73, 0x65, 0x74, 0x75, 0x70, 0x2f, 0x69, 0x63, 0x6f, 0x6e, 0x2e,
    0x70, 0x6e, 0x67, 0x13, 0x66, 0x6e, 0x3d, 0x44, 0x42, 0x42, 0x20, 0x43,
    0x68, 0x72, 0x6f, 0x6d, 0x65, 0x63, 0x61, 0x73, 0x74, 0x20, 0x4c, 0x08,
    0x63, 0x61, 0x3d, 0x31, 0x32, 0x32, 0x39, 0x33, 0x04, 0x73, 0x74, 0x3d,
    0x30, 0x0f, 0x62, 0x73, 0x3d, 0x46, 0x41, 0x38, 0x46, 0x43, 0x41, 0x37,
    0x38, 0x33, 0x38, 0x38, 0x35, 0x04, 0x6e, 0x66, 0x3d, 0x31, 0x03, 0x72,
    0x73, 0x3d, 0xc0, 0x2e, 0x00, 0x21, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78,
    0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x49, 0x24, 0x63, 0x34, 0x64,
    0x37, 0x63, 0x39, 0x39, 0x34, 0x2d, 0x33, 0x39, 0x31, 0x36, 0x2d, 0x65,
    0x31, 0x36, 0x65, 0x2d, 0x37, 0x34, 0x62, 0x64, 0x2d, 0x39, 0x66, 0x32,
    0x65, 0x32, 0x65, 0x61, 0x62, 0x65, 0x35, 0x65, 0x63, 0xc0, 0x1d, 0xc1,
    0x34, 0x00, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x04, 0xac,
    0x11, 0x20, 0x8a,
};

std::vector<std::string> SplitByDot(const std::string& domain_part) {
  std::vector<std::string> result;
  auto copy_it = domain_part.begin();
  for (auto it = domain_part.begin(); it != domain_part.end(); ++it) {
    if (*it == '.') {
      result.emplace_back(copy_it, it);
      copy_it = it + 1;
    }
  }
  if (copy_it != domain_part.end()) {
    result.emplace_back(copy_it, domain_part.end());
  }
  return result;
}

void BrowseDemo(const mdns::DomainName& service_type) {
  auto mdns_adapter = std::unique_ptr<mdns::MdnsResponderAdapter>(
      new mdns::MdnsResponderAdapterImpl);
  mdns_adapter->Init();
  mdns_adapter->StartPtrQuery(service_type);
  mdns_adapter->OnDataReceived({{192, 168, 0, 2}, 12345},
                               {{224, 0, 0, 251}, 5353}, data, sizeof(data), 0);
  mdns_adapter->Execute();

  auto ptr = mdns_adapter->TakePtrResponses();
  DCHECK_EQ(ptr.size(), 1);
  LOG_INFO << "PTR: " << ptr[0].service_instance;
  mdns_adapter->StartSrvQuery(ptr[0].service_instance);
  mdns_adapter->StartTxtQuery(ptr[0].service_instance);

  mdns_adapter->Execute();
  auto srv = mdns_adapter->TakeSrvResponses();
  DCHECK_EQ(srv.size(), 1);
  LOG_INFO << "SRV: " << srv[0].domain_name << ":" << srv[0].port;
  mdns_adapter->StartAQuery(srv[0].domain_name);
  auto txt = mdns_adapter->TakeTxtResponses();
  DCHECK_EQ(txt.size(), 1);
  LOG_INFO << "TXT:";
  for (const auto& line : txt[0].txt_info) {
    LOG_INFO << " | " << line;
  }

  mdns_adapter->Execute();
  auto a = mdns_adapter->TakeAResponses();
  DCHECK_EQ(a.size(), 1);
  LOG_INFO << "A: " << static_cast<int>(a[0].address.bytes[0]) << "."
           << static_cast<int>(a[0].address.bytes[1]) << "."
           << static_cast<int>(a[0].address.bytes[2]) << "."
           << static_cast<int>(a[0].address.bytes[3]);

  mdns_adapter->Close();
}

}  // namespace
}  // namespace openscreen

int main(int argc, char** argv) {
  std::string service_type("_googlecast._tcp");
  if (argc >= 2) {
    service_type = argv[1];
  }

  openscreen::mdns::DomainName d;
  if (!openscreen::mdns::DomainName::FromLabels(
          openscreen::SplitByDot(service_type), &d)) {
    return 1;
  }
  openscreen::BrowseDemo(d);

  return 0;
}
