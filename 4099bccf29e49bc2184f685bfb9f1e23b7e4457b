{
  "comments": [
    {
      "key": {
        "uuid": "f8e15c5b_e568838b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-12-28T00:11:54Z",
      "side": 1,
      "message": "IIUC, this requires callers to use a hot loop, which the previous approach was designed to avoid\n\nIf the caller gets back a kAgain from write, then that would signal that the write failed and they need to try again, correct? In that case, they have no way of knowing how long to wait. So their only option is a hot loop:\n\nwhile (result \u003d\u003d kAgain) {\n  result \u003d Send();\n}\n\nThe previous approach, while not perfect, allowed for asynchronous waits:\n\nOnWritesUnblocked {\n  SendAsMuchDataAsICan();  // Send data until it\u0027s blocked again.\n}\n\nMy understanding based on our previous discussions was that you wanted to use a boolean return value to simplify that SendAsMuchAsICan() method above. After adding a boolean, it becomes send until we get back a false, then stop. \n\nI might be misunderstanding how you intend for the new Send() method to be used - lets plan to discuss it next week",
      "range": {
        "startLine": 11,
        "startChar": 5,
        "endLine": 13,
        "endChar": 17
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3104d21_c6a9de82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-12-30T22:52:02Z",
      "side": 1,
      "message": "In any scheme, we are always going to have to deal with flow control...somewhere. So, the question is whether to handle that internally, within a TlsConnection impl, or to require the producer(s) deal with it. It\u0027s clear the operating system (POSIX send() API) does not want to deal with it, and it\u0027s for the same reasons we don\u0027t want our platform impl (i.e., the old approach) to deal with it:\n\n1. The way the platform impl was dealing with it was to have a queue of \"couldn\u0027t send yet\" messages. This queue could grow indefinitely, and easily OOM the whole application if a connection never recovered. And, if the connection does recover, that queue is going to suddenly burst-send everything all at once. (Like a water dam breaking and flooding the valley below.)\n\n2. The producer(s) of these messages are the entities that best know how to deal with a message send failure. Some use case considerations:\n\n  a. Not all messages require guaranteed delivery. For example, some may be status messages that can simply be resent with updated values later. So, instead of your \"hot loop,\" typical code might look like:\n\n  if (!connection.Send(\u003cpacket\u003e).ok()) {\n    task_runner_-\u003ePostDelayedTask(\n        std::bind(\u0026SendStatusUpdate, this),\n        std::chrono::seconds(10));\n  }\n\n  b. Some messages require timeliness. For example, a video player\u0027s PLAY/SEEK/etc messages should propagate with as little latency as possible. If such control messages cannot be sent immediately, we don\u0027t want to queue them up because the user may take other actions in the meantime. In this case, it\u0027d be best NOT to try to send old control messages that contradict what the user is trying to do right now. It would only frustrate the user to wait while all their previous, stale commands are forced through and executed one-by-one.\n\n...and there are a host of other reasons, but I think the above is enough justification for the new approach.\n\nActually, in light of the above explanation, it may make sense to take our buffer size down from 1/2 MB to something like 32 KB. The TlsConnection is not meant to be a high-bandwidth connection, after all. In fact, maybe boringssl or the operating system is providing enough of a buffer that we don\u0027t need/want one at all?",
      "parentUuid": "f8e15c5b_e568838b",
      "range": {
        "startLine": 11,
        "startChar": 5,
        "endLine": 13,
        "endChar": 17
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "559ed89e_ee6bac3b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-03T23:03:37Z",
      "side": 1,
      "message": "That makes sense. I agree this approach is probably better suited to our use case based on your description of #2 above\n\nMy only other concern is that the task doing the write may be on the task runner. We might have code that says:\n\nvoid WriteThings() {\n  TaskRunner::PostTask(Write(a))\n  TaskRunner::PostTask(Write(b))\n  TaskRunner::PostTask(Write(c))\n}\n\nThen, when these are executed in order\ntime\u003d1. Write(a) returns kAgain, so we re-queue the write\ntime\u003d2. The TLS Write thread executes, and the queue is cleared out.\ntime\u003d3. Write(b) returns No error, because by then the write queue has been cleared\ntime\u003d4. Write(c) also succeeds\ntime\u003d5. Write(a) succeeds the second time\ntime\u003d6. TLS Write thread executes again and all TLS messages are sent out.\n\nThen, we\u0027ve written b, c, a\nwhile the intended order is a, b, c\n\nIf all of our messages are commutative, this wouldn\u0027t be a problem.\nI don\u0027t think that\u0027s true though - If A \u003d start_cast and C \u003d stop_cast, then the end state would be start_cast rather than stop_cast (not to mention, we are assuming that the receiver can handle receiving an invalid command. IE: Stop Casting when nothing is casting. Based on previous discussions, this seems to be a bad assumption)\n\nWhat are your thoughts?",
      "parentUuid": "b3104d21_c6a9de82",
      "range": {
        "startLine": 11,
        "startChar": 5,
        "endLine": 13,
        "endChar": 17
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11fec9b7_bbd14daa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-01-11T00:01:39Z",
      "side": 1,
      "message": "\u003e void WriteThings() {\n \u003e   TaskRunner::PostTask(Write(a))\n \u003e   TaskRunner::PostTask(Write(b))\n \u003e   TaskRunner::PostTask(Write(c))\n \u003e }\n \u003e\n \u003e ...\n \u003e Then, we\u0027ve written b, c, a\n \u003e while the intended order is a, b, c\n\nYou would never want to post \"best-effort\" tasks requiring a specific ordering directly. Instead, you would post tasks that manage progress and make attempts and retries, like:\n\n  std::queue\u003c...\u003e pending_control_messages_;\n\n  void WriteThings() {\n    while (!pending_control_messages_.empty()) {\n      if (!Write(pending_control_messages_.front())) {\n        task_runner_-\u003ePostDelayedTask(\n            std::bind(\u0026WriteThings, this),\n            \u003csome retry delay\u003e);\n        // (Usually better to use a util::Alarm instead to\n        // manage auto-cancelable delayed tasks.)\n        return;\n      }\n      pending_control_messages_.pop_front();\n    }\n  }\n\n\u003e If all of our messages are commutative, this wouldn\u0027t be a problem.\n \u003e I don\u0027t think that\u0027s true though - If A \u003d start_cast and C \u003d stop_cast, then ...\n\nThe class/entity that sends the control message(s) will also know whether any message has been accepted for reliable delivery to the receiver. So, the class/entity would probably have control logic like (oversimplified example here):\n\n  enum State { IDLE, PLAY, PAUSE, STOP, QUIT };\n  State posted_state_;\n  State desired_state_;\n\n  void UpdateIfNecessary() {\n    if (posted_state_ !\u003d desired_state_) {\n      if (Write(\u003ccontrol message to get to desired_state_\u003e)) {\n        posted_state_ \u003d desired_state_;\n      } else {\n        // schedule retry at later time\n      }\n    }\n  }\n\n  void SetDesiredState(State x) {\n    desired_state_ \u003d x;\n    UpdateIfNecessary();\n  }\n\nSo, desired_state_ could be changed by the user even while some previous desired state was never communicated to the receiver; and, this would be good because it effectively auto-cancels old state changes that the user no longer wants (and no thrashing the receiver with rapid, useless state changes).",
      "parentUuid": "559ed89e_ee6bac3b",
      "range": {
        "startLine": 11,
        "startChar": 5,
        "endLine": 13,
        "endChar": 17
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c31d891_8bb75637",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-11T00:09:02Z",
      "side": 1,
      "message": "That makes sense. Thanks for the clarification!",
      "parentUuid": "11fec9b7_bbd14daa",
      "range": {
        "startLine": 11,
        "startChar": 5,
        "endLine": 13,
        "endChar": 17
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fffe882f_9712c7da",
        "filename": "cast/common/channel/cast_socket.h",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-03T23:03:37Z",
      "side": 1,
      "message": "Cool - I didn\u0027t know you could do that",
      "range": {
        "startLine": 58,
        "startChar": 18,
        "endLine": 58,
        "endChar": 25
      },
      "revId": "4099bccf29e49bc2184f685bfb9f1e23b7e4457b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}