{
  "comments": [
    {
      "key": {
        "uuid": "7404a415_2190d787",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 32,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "This notify_all() call shouldn\u0027t be necessary, right? It would assume there is already some other thread running tasks, which there shouldn\u0027t be (that would be a serious logic flaw in the caller).\n\nThis infers that an atomic swap should be used:\n\n  const bool was_runnning \u003d is_running_.exchange(true);\n  OSP_CHECK(!was_running);",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 32,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2404e535_0501d79c",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 32,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "I think you have to acquire |task_mutex_| before you can signal the cond var, right? (And, in Stop() too.)",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 32,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3810bed_3933e547",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 51,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "if we used an std::atomic\u003cdeque\u003c...\u003e\u003e we could have an atomic swap operation without locking. Given how frequently this method is run, it seems worth the extra complexity to get the associated perf gain from avoiding using the lock. Thoughts?",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 51,
        "endChar": 23
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2691325_24feaf1a",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 51,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "I doubt std::atomic\u003cdeque\u003e is lock-free: https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free",
      "parentUuid": "f3810bed_3933e547",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 51,
        "endChar": 23
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77b4fe8b_4ecabbf8",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 51,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-04-03T19:01:12Z",
      "side": 1,
      "message": "/Library/Developer/CommandLineTools/usr/include/c++/v1/atomic:896:13: error: _Atomic cannot be applied to type \u0027std::__1::deque\u003cstd::__1::function\u003cvoid ()\u003e, std::__1::allocator\u003cstd::__1::function\u003cvoid ()\u003e \u003e \u003e\u0027 which is not trivially copyable\n    mutable _Atomic(_Tp) __a_;\n\nI don\u0027t think we can atomicize std::deque, unless I\u0027m just missing something.",
      "parentUuid": "f3810bed_3933e547",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 51,
        "endChar": 23
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89528aec_7c7b9d39",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 64,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "Add a comment about what this check is checking - the parallelism that makes it not immediately clear",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 29
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f447aba_b35c4e21",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 64,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "IMHO, it\u0027d read better to just put the code in RunCurrentTasks() in this method (i.e., don\u0027t have two separate methods).",
      "parentUuid": "89528aec_7c7b9d39",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 29
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b7caee8_c5017189",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 64,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-04-03T19:01:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "89528aec_7c7b9d39",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 29
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4f1c91a6_b0b82aa0",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 71,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "When the context is re-acquired, we need to wait for the lock to get re-acquired. Is there any alternative synchronization mechanism we can use that doesn\u0027t incur this cost?",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 71,
        "endChar": 36
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8f3bd0f_f1d10705",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 71,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "I don\u0027t understand: A lock always has to be held while reading/mutating the task queues, right?",
      "parentUuid": "4f1c91a6_b0b82aa0",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 71,
        "endChar": 36
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d6cede2a_c2a4d2d4",
        "filename": "api/impl/task_runner_impl.cc",
        "patchSetId": 12
      },
      "lineNbr": 81,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "Sampling the clock can be \"expensive\" on some platforms (e.g., on Windows sometimes a global mutex is acquired!). I suggest just calling now_function_() once, and using the same value for comparison:\n\n  std::lock_guard...\n\n  if (delayed_tasks_.empty()) {\n    return;\n  }\n\n  Clock::time_point now \u003d now_function_();\n\n  while (delayed_tasks_.empty() \u0026\u0026 ...top... \u003c now) {\n    ...\n  }",
      "range": {
        "startLine": 81,
        "startChar": 53,
        "endLine": 81,
        "endChar": 68
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7472095a_b2a4a767",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 28,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "C++ style: Need explicit keyword for single-arg ctor.",
      "range": {
        "startLine": 28,
        "startChar": 2,
        "endLine": 28,
        "endChar": 16
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46ab5e17_2aed2406",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 39,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "Looking at this again, a couple things:\n\n1. Naming: Since Start() will block the current thread indefinitely (or until Stop()), consider adjusting its naming. Maybe Run() or RunUntilStopped()? To me, the \"Start\" naming sounds like it spawns some separate async operation, and is non-blocking. Note that the corresponding \"Stop\" does not block (maybe it should be named StopSoon() or RequestStopSoon()?).\n\n2. Stop() can race with Start(). This probably wouldn\u0027t happen in practice, but Chromium\u0027s task runner mitigates this race by requiring posting quit tasks. IIRC, you had this in a prior patch set.",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 39,
        "endChar": 14
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fbd8e1e_f9175381",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 44,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "What are your thoughts on making this private and making the UT class a Friend class of this one? It seems a bit weird to expose a method as public but expect that it\u0027s never actually used",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 44,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78fc8607_dae04ac2",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 44,
      "author": {
        "id": 1002897
      },
      "writtenOn": "2019-04-03T13:05:16Z",
      "side": 1,
      "message": "Chromium has a PRESUBMIT check that verifies that *ForTesting() methods are not called from production code. Therefore, it is common to have public *ForTesting() methods, without friending.",
      "parentUuid": "7fbd8e1e_f9175381",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 44,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d58642b6_f59bba0b",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 44,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T15:40:08Z",
      "side": 1,
      "message": "That\u0027s really cool! In OpenScreen, do we have the same thing? I know there is a bunch of other Chromium tooling we don\u0027t have implemented in our repo",
      "parentUuid": "78fc8607_dae04ac2",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 44,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f990e92_3b726054",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 44,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-04-03T19:01:12Z",
      "side": 1,
      "message": "I don\u0027t think we do, but I would be in favor of adding it and using the same pattern.",
      "parentUuid": "d58642b6_f59bba0b",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 44,
        "endChar": 32
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b41808ae_83ec5e12",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 49,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "task(std::move(task_))",
      "range": {
        "startLine": 49,
        "startChar": 15,
        "endLine": 49,
        "endChar": 20
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a760e942_de361230",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 60,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "Are there any cases where we care about the number ran instead of just a true/false? Might be worth returning a uint instead of bool",
      "range": {
        "startLine": 59,
        "startChar": 46,
        "endLine": 60,
        "endChar": 29
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a29b7874_c29ac01a",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 60,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-04-03T19:01:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a760e942_de361230",
      "range": {
        "startLine": 59,
        "startChar": 46,
        "endLine": 60,
        "endChar": 29
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aef39a72_515f2792",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 71,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "C++ style: const platform::ClockNowFunctionPtr function_; since it doesn\u0027t change after being init\u0027ed by the ctor.",
      "range": {
        "startLine": 71,
        "startChar": 2,
        "endLine": 71,
        "endChar": 31
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6393e604_c86fb14a",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 74,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-04-03T01:02:32Z",
      "side": 1,
      "message": "why are you using an atomic_bool instead of regular bool?\n\nlooking at the below code, you never try to modify and read in the same place, and any single read or write operation is atomic for a standard bool",
      "range": {
        "startLine": 74,
        "startChar": 2,
        "endLine": 74,
        "endChar": 31
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc2f1c5b_14d59e48",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 74,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "We have to be careful: The \"plain bool is atomic\" assumption is only true on certain architectures.",
      "parentUuid": "6393e604_c86fb14a",
      "range": {
        "startLine": 74,
        "startChar": 2,
        "endLine": 74,
        "endChar": 31
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b31687e_43738ae2",
        "filename": "api/impl/task_runner_impl.h",
        "patchSetId": 12
      },
      "lineNbr": 74,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-04-03T19:01:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6393e604_c86fb14a",
      "range": {
        "startLine": 74,
        "startChar": 2,
        "endLine": 74,
        "endChar": 31
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "603e3da9_35f5f43a",
        "filename": "api/impl/task_runner_unittest.cc",
        "patchSetId": 12
      },
      "lineNbr": 58,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-04-03T18:32:48Z",
      "side": 1,
      "message": "Suggestion: Post a second task that runs in 10 ms, then, below:\n\n  WaitUntilCondition([\u0026ran_tasks] { return ran_tasks \u003d\u003d \"12\"; });\n\n(to confirm multiple delayed tasks run in order)",
      "range": {
        "startLine": 58,
        "startChar": 2,
        "endLine": 58,
        "endChar": 46
      },
      "revId": "a498f20b02463ea323259a417726cfc3b434d4e1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}