{
  "comments": [
    {
      "key": {
        "uuid": "25a10beb_18e359a6",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-12T18:34:08Z",
      "side": 1,
      "message": "In the example here https://en.cppreference.com/w/cpp/utility/program/signal sig_atomic_t is used. Is this something that should be used here?",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 25,
        "endChar": 31
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d420358_d122df48",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-03-12T21:18:36Z",
      "side": 1,
      "message": "I had a version of the code that did that, but dropped it. The purpose of this var is to distinguish between three cases: 1) no signal handler is installed yet; 2) signal handler is installed but no signal yet; 3) signal handler is installed and got a signal. These three cases don\u0027t map 1:1 to sig_atomic_t values (SIGABRT, SIGSEGV, etc.).\n\nstd::sig_atomic_t is platform-defined. It could be as simple as \"typedef int\", but it could also be something OS-specific like \"struct { things }\". So, I didn\u0027t want to just assume it was int, use my own custom values, and then find out the code isn\u0027t portable later on.",
      "parentUuid": "25a10beb_18e359a6",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 25,
        "endChar": 31
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad620bbf_ea4f96b7",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-12T18:34:08Z",
      "side": 1,
      "message": "Understandable, that you didn\u0027t want to make it a part of TaskRunner public API.\nWhy standalone_receiver is using TaskRunnerImpl directly though?",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 13
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e980ef26_04fbb325",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-03-12T21:18:36Z",
      "side": 1,
      "message": "Not sure. It didn\u0027t need to before, but it does now. ðŸ˜Š",
      "parentUuid": "ad620bbf_ea4f96b7",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 13
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22fd1835_99c2c88f",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2020-03-12T21:44:15Z",
      "side": 1,
      "message": "If we think of the sender/receiver standalone apps as example/reference usages of our platform/api in my opinion it doesn\u0027t bode well to set the precedent of using impl instead of the interface here.\nExcluding RunUntilSignalled how much has to change to use TaskRunner instead of TaskRunnerImpl?",
      "parentUuid": "e980ef26_04fbb325",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 13
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c9fbef0_ac7c0bce",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-03-12T22:14:00Z",
      "side": 1,
      "message": "\u003e If we think of the sender/receiver standalone apps as example/reference usages of our platform/api in my opinion it doesn\u0027t bode well to set the precedent of using impl instead of the interface here.\n\nI agree with your statement for library code (i.e., most Open Screen code), but not embedder code. Basically, which side of the \"platform/api boundary\" are we on? The library code that calls into it, or the embedder that implements it? The main.cc\u0027s here are on the embedder side, as they have to be able construct/own/drive some concrete impl of the public/api interface, right? And, if they have to do that, then I don\u0027t believe it\u0027s a layering violation for them to call into TaskRunnerImpl instead of the interface.\n\nFWIW, the TaskRunnerImpl type is limited to just the main.cc\u0027s (even on the embedder side, in the standalone apps, we pass just the interface outside of the main.cc\u0027s). Also, there are DEPS rules to prevent platform/impl from being used in any code outside of \"standalone applications.\"",
      "parentUuid": "22fd1835_99c2c88f",
      "range": {
        "startLine": 69,
        "startChar": 2,
        "endLine": 69,
        "endChar": 13
      },
      "revId": "5fb8503f40d54853108df925ab9635d4d2cfd375",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}