{
  "comments": [
    {
      "key": {
        "uuid": "070a37b6_fa0e043e",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-09-19T17:24:18Z",
      "side": 1,
      "message": "I don\u0027t see what atomics achieve here.\n\nTwo threads enter Write. Each thread atomically reads write_index_ and gets the same value.\nThen each thread proceeds independently, and independently, but atomically, updates write_index_ to potentially different values.",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 51
      },
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95f05208_0636858a",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-19T17:41:17Z",
      "side": 1,
      "message": "Based on the class-level comment, we only ever expect one thread to be acting as the publisher and one (potentially different) thread acting as the consumer. So we need concurrent calls to Reading and Write() to work, but not multiple calls to Write()\n\nIf we want to support multiple publishers or multiple consumers, the code gets much more complex (and/or needs mutexes), but we don\u0027t need this at least with our current approach",
      "parentUuid": "070a37b6_fa0e043e",
      "range": {
        "startLine": 30,
        "startChar": 2,
        "endLine": 30,
        "endChar": 51
      },
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd8d1382_3e037a43",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "const",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c96194cc_ba72d0d9",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bd8d1382_3e037a43",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "acf1b065_5b9b6712",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "const",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53835b2d_1deb7e3d",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "acf1b065_5b9b6712",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3faa7a7d_79ce49cf",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 36,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "This part of the code gets a little dense for my tastes.\n\nwrite_len is the minimum of (1) the remaining space in the buffer and (2) the length of the data that we want to write.\n\nfirst_write_len is the minimum of write_len and the size of the buffer minus the current write location? This is to handle the overflow case, right, e.g. the first memcpy could take\n\n[0000|read_index|XXX|write_index|000]\n\nand make it\n\n[0000|read_index|XXX|write_index|AAA]\n\nThen new_start and the second memcpy only apply if we haven\u0027t written the whole thing:\n\n[BBBB|read_index|XXX|write_index|000]\n\nThen we store the new write index.\n\n\nI would love some commenting and additional clarity in this area, maybe some better names too. E.g. replace first_write_len with write_len_without_wrapping?",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e6e51de_ee9dac5d",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 36,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Good point - this are some pretty dense calculations. I\u0027ve added some pretty extensive comments (which hopefully should explain where these names come from), so PTAL and open a new comment if you would like further changes.",
      "parentUuid": "3faa7a7d_79ce49cf",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d331c464_072e98d3",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "all const?",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1358c7f7_039bd227",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d331c464_072e98d3",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3dedfc91_7338faa1",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "couldn\u0027t your readable region include (0, current_write_index] when current_write_index \u003c current_read_index?",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ceff4b3_dc6ded17",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "It could, but the API specifies that the returned area may not be the entire readable area - and supporting a read that wraps around involves copying to a temporary buffer of large enough size\n\nGiven both, there is no reason to not require 2 reads instead of 1 (especially given that we expect reads to be done in while(true) loop)\n\nAdding a comment to this effect - please open a new comment if you disagree",
      "parentUuid": "3dedfc91_7338faa1",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1c29c8f0_eed6cdce",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "Just curious, why GetReadableRegion + Consume instead of just Read?",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18ea24da_e1c86514",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "They may not read the full readable data. ie, BoringSSL\u0027s write method will write a subset of the provided data, not necessarily all of it",
      "parentUuid": "1c29c8f0_eed6cdce",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fe3c084b_37a9afd8",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "const again.",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1b03e54_2589788e",
        "filename": "platform/impl/tls_write_buffer.cc",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fe3c084b_37a9afd8",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b6e00e8c_33a063e8",
        "filename": "platform/impl/tls_write_buffer.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-20T19:13:46Z",
      "side": 1,
      "message": "Comment is out of date.",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1881c9f0_c8c1c0a0",
        "filename": "platform/impl/tls_write_buffer.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-20T20:23:40Z",
      "side": 1,
      "message": "Actually the comment is still correct. The parameters are just... unexpected for this operation, so adding an extra line to reflect this. Internally, it does some math and then calls Observer::NotifyWriteBufferFill(...) with a value calculated based on the write and read indices provided\n\nLet me know if this seems better to you",
      "parentUuid": "b6e00e8c_33a063e8",
      "revId": "0b98e560605173f7b39e3119e185abe5aed8a902",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}