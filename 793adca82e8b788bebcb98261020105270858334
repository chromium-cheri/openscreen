{
  "comments": [
    {
      "key": {
        "uuid": "fbd3a6d2_e87b3a54",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 160,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-31T01:27:59Z",
      "side": 1,
      "message": "Please document how this list is ordered",
      "range": {
        "startLine": 157,
        "startChar": 0,
        "endLine": 160,
        "endChar": 4
      },
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d63de73d_d9191304",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 160,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-02-01T00:50:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fbd3a6d2_e87b3a54",
      "range": {
        "startLine": 157,
        "startChar": 0,
        "endLine": 160,
        "endChar": 4
      },
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7bc5c783_5bca81f6",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2020-01-30T23:04:46Z",
      "side": 1,
      "message": "Why put NONE in the list at all? We shouldn\u0027t ever get uncoded content right?",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e970d18_4fec2609",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-31T01:27:59Z",
      "side": 1,
      "message": "It looks like so that line 165 doesn\u0027t overwrite any of the codecs to try?\nSpent a while trying to come up with a clearer way to write this. Best I could come up with was this, though I don\u0027t know if it\u0027s actually any clearer. Your call which to use:\n\n  namespace {\n    constexpr std::array\u003cAVCodecID\u003e kCodecsToTry \u003d { ... };\n  }\n\n  ...\n\n  AVCodecID Decoder::Detect(const std::string\u0026 expected_codec_name,\n                            const Buffer\u0026 buffer) {\n    // Iterate across all valid codecs\n    auto it \u003d kCodecsToTry.first();\n\n    // Find the first codec to try\n    AVCodecID codec_to_try \u003d AV_CODEC_ID_NONE;\n    if (!expected_codec_name.empty()) {\n      if (AVCodec* codec \u003d\n              avcodec_find_decoder_by_name(expected_codec_name.c_str())) {\n        codec_to_try \u003d codec-\u003eid;\n      } else {\n        OSP_LOG_WARN \u003c\u003c \"Expected codec not available: \" \u003c\u003c expected_codec_name;\n      }\n    } \n\n    if (codec_to_try \u003d\u003d AV_CODEC_ID_NONE) {\n      codec_to_try \u003d *it++;\n    }\n\n    // Check all codecs until one works\n    for (; it !\u003d kCodecsToTry.end(); codec_to_try \u003d *it++) {\n      ...\n    }",
      "parentUuid": "7bc5c783_5bca81f6",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e339d6a_c0fd6c96",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 173,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-02-01T00:50:07Z",
      "side": 1,
      "message": "Done: Removed the special NONE check, used an variable-start iterator to walk the whole list or skip the first NONE element.",
      "parentUuid": "5e970d18_4fec2609",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2f52b861_c51e1fd1",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 179,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-31T01:27:59Z",
      "side": 1,
      "message": "All the comments will definitely make life easier - and work great as code documentation! I\u0027m going to need to go back and do the same to discovery",
      "range": {
        "startLine": 179,
        "startChar": 0,
        "endLine": 179,
        "endChar": 76
      },
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3b466ad9_ba7fb7e6",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 194,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-31T01:27:59Z",
      "side": 1,
      "message": "Why could this fail? Probably warrants a comment or details to the OSP_CHECK() stream",
      "range": {
        "startLine": 194,
        "startChar": 4,
        "endLine": 194,
        "endChar": 22
      },
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb8ff3a6_9f99a8f0",
        "filename": "cast/standalone_receiver/decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 194,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-02-01T00:50:07Z",
      "side": 1,
      "message": "Done.\n\nFFMPEG library docs say av_packet_alloc() can return NULL on failure. I\u0027d rather the app crash on OOM since it\u0027s unreasonable to handle/workaround that failure case.",
      "parentUuid": "3b466ad9_ba7fb7e6",
      "range": {
        "startLine": 194,
        "startChar": 4,
        "endLine": 194,
        "endChar": 22
      },
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7aa04943_90046ff5",
        "filename": "cast/standalone_receiver/decoder.h",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2020-01-30T23:04:46Z",
      "side": 1,
      "message": "Can we expose a list of known codecs that the Decoder should know, so that this can be strongly typed? If the user passes a value like \"h 264\" instead of \"H264\", we should probably know ASAP and not call down through multiple layers?\n\nI know it\u0027s a suggestion here (we try other codecs), but that seems cleaner to me.",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a02f8498_0a419cfb",
        "filename": "cast/standalone_receiver/decoder.h",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2020-01-31T01:27:59Z",
      "side": 1,
      "message": "+1\n\nIf not, it\u0027s probably worth DCHECK\u0027ing against a whitelist",
      "parentUuid": "7aa04943_90046ff5",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d355bec_31fdc346",
        "filename": "cast/standalone_receiver/decoder.h",
        "patchSetId": 1
      },
      "lineNbr": 51,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2020-02-01T00:50:07Z",
      "side": 1,
      "message": "Added some header comments to clarify intended usage. Responses to individual points:\n\n\u003e Can we expose a list of known codecs that the Decoder should know,\n\nWe could, but at this point it would be over-engineering things, IMO. FFMPEG has this known-codec list internally, and we\u0027re using its look-up function to find the codec implementation (and iff it is installed on the system).\n\nWe would only want to expose this list to compare it to OFFER messages from a Sender before sending an ANSWER that selects which streams the Receiver wants. We could add that to the standalone receiver app as a future enhancement.\n\n\u003e so that this can be strongly typed?\n\nThis string comes from an OFFER message. The Cast Streaming control message spec defines certain known/required values (e.g., \"vp8\" and \"opus\" and \"h264\"), but also leaves the field open for any arbitrary codec by any name for future use.\n\nAlso, why should this not be a string? Isn\u0027t it cool that our standalone receiver app could potentially work with ANY codec provided by FFMPEG for free? ðŸ˜Š\n\n\u003e If the user passes a value like...\n\nThere is no user interaction here. Passing strings with typos would be both a Sender bug (for sending an bad codec_name in an OFFER), and a Receiver bug (for sending an ANSWER choosing a stream with a bad codec_name).\n\n\u003e If not, it\u0027s probably worth DCHECK\u0027ing against a whitelist\n\nWe do not want the app to crash on an invalid (or valid, but unrecognized) external data input. We already have an OnFatalError() callback that is invoked if a codec is not available, and this bubbles up to the main receiver app workflow for handling.",
      "parentUuid": "a02f8498_0a419cfb",
      "revId": "793adca82e8b788bebcb98261020105270858334",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}