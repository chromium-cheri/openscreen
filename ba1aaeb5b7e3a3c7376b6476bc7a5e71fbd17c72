{
  "comments": [
    {
      "key": {
        "uuid": "9fbdf44f_ce5fb33b",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-10-08T17:10:32Z",
      "side": 1,
      "message": "move vs state vs operation.\nI think it would be a bit better if it was one of the three throughout, probably operation as networking mode and state could mean a lot of things",
      "range": {
        "startLine": 79,
        "startChar": 2,
        "endLine": 79,
        "endChar": 46
      },
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ffe81693_99390bf9",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T19:13:08Z",
      "side": 1,
      "message": "Done. Updated to operation",
      "parentUuid": "9fbdf44f_ce5fb33b",
      "range": {
        "startLine": 79,
        "startChar": 2,
        "endLine": 79,
        "endChar": 46
      },
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d611c7c_896c2921",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 83,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:05:08Z",
      "side": 1,
      "message": "This is holding onto the lock for the entire duration of this method (presumably, until the timeout).\n\nCan you make a stack copy of connections_ under the lock and loop over that?\n\nOr will this lock be removed when we integrate the subscription object into this class?",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81a4c919_36d9951b",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 83,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T23:30:42Z",
      "side": 1,
      "message": "This may be removed after we integrate the Subscription CL into the class. The TODO above is related to this\n\nFor now, this is all under the lock because it\u0027s possible that a connection will be destroyed while we are using it, which would result in a segfault",
      "parentUuid": "8d611c7c_896c2921",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbea0e1f_fea7920c",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 83,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:42:32Z",
      "side": 1,
      "message": "OK.  I don\u0027t see how the lock quite helps, since the connection can be destroyed independently of the lock being held or not.\n\nLet\u0027s see how the code looks after the subscriber object is implemented.",
      "parentUuid": "81a4c919_36d9951b",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8928b783_3e605278",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 89,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:05:08Z",
      "side": 1,
      "message": "Where is connections_ populated? I don\u0027t see any code that inserts into it.  Is that code TBD?",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a5a5bd6_29f26751",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 89,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T23:30:42Z",
      "side": 1,
      "message": "This is TBD. Falls under TaskList item \"TlsNetworkingManager Subscribe / Unsubscribe x 2\"\n\nI expect this will be done with the SubscriberModel class that\u0027s currently in CL",
      "parentUuid": "8928b783_3e605278",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "753cee2e_f77fe25d",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 103,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:05:08Z",
      "side": 1,
      "message": "This seems like a slightly complicated way to loop through reads/writes.  Is there a reason you can only do one operation at a time in this loop?\n\nYou could call TryReceive() and Send() on each connnection in a loop,\nor you could loop through the connections twice (once for sending, and once for receiving).",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7a486eb_7a6558bf",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 103,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T23:30:42Z",
      "side": 1,
      "message": "The reason for this is to exit more quickly when doing Send/Recieve\n\nIf we hit the timeout, we want to exit as quickly as possible. Then, the following iteration, we want to pick up where we left off (so that we don\u0027t always do reading and never writing for instance). In the worst case scenario, we might only ever get one Read or Write done before the timeout (which is why we have a do-while loop instead of a while loop)\n\nAs an exampleo:\nconnection1, read\nconnection1, write\nconnection2, read\nTIMEOUT\n\nWhat we would want is for the following iteration to start right where we left off (at Connection2, write), so that no single connection or operation is favored\n\nWith the approaches you suggest, either we take longer to stop after the timeout has been hit (first approach), or we may never actually do one of read/write if we always timeout after doing the first",
      "parentUuid": "753cee2e_f77fe25d",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "977c5123_db4f19a8",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 103,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:42:32Z",
      "side": 1,
      "message": "Ah ok, you want to implement round-robin operations so there\u0027s some fairness.  That makes perfect sense, thanks.  Can you add a comment after \"// Get the next\" explaining that we are processing the list in a round-robin fashion across timeouts?",
      "parentUuid": "a7a486eb_7a6558bf",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "619203ad_9225c438",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-10-08T17:10:32Z",
      "side": 1,
      "message": "You only have to update this after you exit the loop. Then I think you don\u0027t need start_mode and start_connection, you can compare to last_mode and last_connection below and then update last_mode and last_connection after the loop is done.",
      "range": {
        "startLine": 112,
        "startChar": 4,
        "endLine": 113,
        "endChar": 31
      },
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5dd0e97e_5f25e209",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T19:13:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "619203ad_9225c438",
      "range": {
        "startLine": 112,
        "startChar": 4,
        "endLine": 113,
        "endChar": 31
      },
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "961aff98_2e267676",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 146,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:05:08Z",
      "side": 1,
      "message": "It looks like you\u0027re looping through the connections with an O(N^2) algorithm - by doing a lookup each time.\n\nCan you just use a range loop over connections_ inside the do ... while?",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6feb4c1_fa586ce5",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 146,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-08T23:30:42Z",
      "side": 1,
      "message": "GetConnection is only called once, outside of the loop\nInside the do-while loop, we just call current_connection++ and make use of the iterator which should be O(1) for each of the n iterations :)",
      "parentUuid": "961aff98_2e267676",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd1c39d9_2214288b",
        "filename": "platform/impl/tls_data_router_posix.cc",
        "patchSetId": 5
      },
      "lineNbr": 146,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:42:32Z",
      "side": 1,
      "message": "OK, thanks.  This is starting to make sense.  I assume you can\u0027t always hold onto the iterator itself across loops because it may be invalidated by vector modifications.  But if you know when the vector is modified, it seems like you could loop over an iterator until that happens.\n\nWill this code also go away when the subscription work is done?  If so it\u0027s not worth tweaking it further.",
      "parentUuid": "f6feb4c1_fa586ce5",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14ce0d7f_d25790a1",
        "filename": "platform/impl/tls_data_router_posix.h",
        "patchSetId": 5
      },
      "lineNbr": 78,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-08T23:05:08Z",
      "side": 1,
      "message": "Typo in iteration",
      "revId": "ba1aaeb5b7e3a3c7376b6476bc7a5e71fbd17c72",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}