{
  "comments": [
    {
      "key": {
        "uuid": "7a449f71_e6654780",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Bikeshed: maybe the \"primary\" thread should be called the \"consumer\" thread, as the other threads in the system are \"producing\" subscribers.",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51cbb994_e5e711d6",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Done. Much clearer naming!",
      "parentUuid": "7a449f71_e6654780",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc48a379_55db0a7c",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Can we just use operation\u003d\u003d for SubscriberType, instead of introducing a custom Equals template parameter?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dca646bf_d0dc58bb",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "If we want to continue to support MapEquals below, we can\u0027t use \u003d\u003d (see comments below). If not, that should be doable\n\nLeaving this comment open pending that descision",
      "parentUuid": "fc48a379_55db0a7c",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14488a84_c097ec2e",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "See reply below.",
      "parentUuid": "dca646bf_d0dc58bb",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c3e46b62_73c803a8",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "The cancellation_token seems to function as a closure (void callback).\nWould it be simpler to just pass a std::function\u003cvoid()\u003e to the constructor?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f0deb45_50456b3c",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c3e46b62_73c803a8",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6fc3a80d_38cd6c50",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Is there a use case for this?  The stated purpose of the class is to allow other threads to unsubscribe *without* blocking.",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b721152f_439a89f8",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "As Unsubscribe is often called in the dtor of subscribed objects, this is expected to be used to block deletion of an object that may not be safe to immediately delete (for instance, block the deletion of a UdpSocket\u0027s socket handle until SocketHandleWaiter is no longer using it for the SELECT call, to ensure we don\u0027t hit a segfault).\n\nThe specific classes that would use this are SocketHandleWaiter (for case mentioned above) and TlsDataRouterPosix (so we don\u0027t delete a TlsConnection as we are reading/writing with it)\n\nAn alternative would be to provide a \"deletion action\" to the Unsubscribe call to be called when the subscriber_changes_ action is executed (ie, for a socket handle, we could transfer the \"close this socket handle\" action like UdpSocketPosix::Close()). I did not go this route because:\n- We already use the currently coded pattern in our library (previously in UdpSocketReader, but since moved to SocketHandleWaiter during the previously discussed refactor while you were at TPAC)\n- This would require larger design changes and design discussions to other already-existing classes (especially because the called action can\u0027t be an instance method if the instance might be deleted), so I thought it would be better to get the code working and leave this as future work",
      "parentUuid": "6fc3a80d_38cd6c50",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "deca0ebf_2c0a8a8c",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "I now realize that this class take a copy of SubscriberType and owns it in Subscribe() and Unsubscribe(), and uses Equals().  But the examples you provided below all pass pointers as SubscriberType.  If you update the API to always pass subscribers by (un-owned) pointer, do we still need to worry about deletion?",
      "parentUuid": "b721152f_439a89f8",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ae97757_cc327061",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-15T22:36:52Z",
      "side": 1,
      "message": "We will still require the same blocking functionality in some cases. The issue isn\u0027t whether the instance is owned, it\u0027s whether we might still be using the instance on the consumer thread when a provider thread tries to delete the pointed to object.\n\nAs an example, in the case of SocketHandleWaiter, the SubscriberType objects are pointers, but the pointed to objects are used on the consumer thread for the posix SELECT call. Unsubscribing is done as part of UdpSocketPosix\u0027s dtor, when the socket is deleted and the socket handle is invalidated. That means that, if the producing thread calls Unsubscribe instead of UnsubscribeBlocking as part of UdpSocket\u0027s deletion from the provider thread, then the underlying socket handle may be invalidated while the consumer thread is still using it for SELECT (Which I\u0027ve validated in local testing can cause a segfault)\n\nWe can use the Cancellation method to minimize the time spent blocked, but we do need to wait for the next call to ApplyPendingChanges() (which is why we might want to call it multiple times instead of just in SubscriberModel::subscribers(). For instance, in the above case, we can call ApplyPendingChanges() after we finish the SELECT call instead of waiting for the next iteration of the SocketHandleWaiter\u0027s run method when we again will call subscribers())\n\nI will update to only use pointers if you would still like that change despite this comment, but one of the cases below uses const refs rather than pointers, so it would be an extra level of indirection for that case",
      "parentUuid": "deca0ebf_2c0a8a8c",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df46e860_a1f2f787",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-16T17:31:58Z",
      "side": 1,
      "message": "I had an alternative idea this morning\n\nWe could instead have StartUsingSubscibers() and StopUsingSubscribers() methods (but with better names). Then, if we are in between StartUsingSubscribers() and StopUsingSubscribers(), UnsubscribeBlocking() would block until we all StopUsingsubscribers(), and else it would return immediately\n\nIf we lock/unlock a mutex inside these methods, we should be able to enforce that subscribers() can only be called between them at compile time with abseil thread annotations.",
      "parentUuid": "5ae97757_cc327061",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ca3f6ed_31a27557",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-10-16T22:12:36Z",
      "side": 1,
      "message": "That\u0027s similar to what I was proposing in an earlier comment:\n\n  std::lock_guard\u003cstd::mutex\u003e StartConsumerTransaction() {\n    return std::lock_guard\u003cstd::mutex\u003e lock(mutex_);\n  }\n\nRather than have separate StartUsingSubscribers() and StopUsingSubscribers(), using std::lock_guard guarantees the lock is only held while in scope. Simplifies the code, client-side not to have to call StopUsingSubscribers() at every return codepoint.\n\nFWIW, this is the same as a problem I solved in the Audio Service code: https://cs.chromium.org/chromium/src/services/audio/loopback_stream.cc?rcl\u003dc4c6a468ab79ed56781f3fea32ae587e9003d986\u0026l\u003d332 In this situation, the \"consumer\" thread had to ensure the object graph did not change while pulling audio samples from several other objects. In other words, yes, it\u0027s okay for the consumer thread to hold the lock for a non-trivial amount of time, while doing its work, if that\u0027s because it requires the object graph be pinned-down while the work is in-progress. Also, note that the code that wants to change the object graph, on the other thread, is very infrequently called (only at startup/shutdown of an audio stream). Thus, the two threads will pretty much never become blocked on each other for any amount of time.",
      "parentUuid": "df46e860_a1f2f787",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f4b1581_302d1965",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 74,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Do we yet have a macro for enforcing thread/sequence affinity, similar to DCHECK_CALLED_ON_VALID_SEQUENCE in Chromium?\n\nWe have a lot of code that is not threadsafe, or has threading assumptions baked in.  It would be great to document and enforce those assumptions in code (not just comments).\n\nFeel free to file an issue and leave as a TODO.",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9348e6db_925f2971",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 74,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Done.\n\nCurrently this is not supported - We have a method to check if we are running on the TaskRunner thread, but that\u0027s all. I\u0027ve filed a bug (https://bugs.chromium.org/p/openscreen/issues/detail?id\u003d74) and added a class-level TODO to enforce these threading assumptions",
      "parentUuid": "3f4b1581_302d1965",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e1117d12_767a0fe5",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 75,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "In general synchronous APIs are discouraged.  What is the use case for this?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4158e0ae_1f0318b8",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 75,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Done.\n\nThis was originally an optimization for when OperationsLoop used a subscriber model\nThe idea was that we could block the Wait loop until there was work to be done, instead of running in a hot loop. \n\nSince OperationLoop no longer uses this model, I\u0027ve removed this method and closed the comment",
      "parentUuid": "e1117d12_767a0fe5",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "37fd5daa_2b3a4b90",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 89,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "I didn\u0027t quite follow this comment.  Calling this method is what processes pending Subscribe and Unsubscribe calls.",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10deefd0_69c730dc",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 89,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Correct, this is what processes subscribe and unsubscribe calls\n\nThis method locks mutex_, so if it is called in a hot loop (and subscriber_changes_ has no new data), a producer may never be able to acquire the mutex in Subscribe() or Unsubscribe() because the consumer consistently owns it, and those threads could starve\n\nI\u0027ve updated the comment to state the same, but if it\u0027s still more confusing than helpful I can remove it :)",
      "parentUuid": "37fd5daa_2b3a4b90",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4c70aff_e42ffec7",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 89,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "Cmment looks good, but see reply below.",
      "parentUuid": "10deefd0_69c730dc",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "859b3abc_ffe5615d",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 90,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Does this need to be part of the public API, or should it be private and called only from Subscribe/Unsubscribe?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6236d55_9686b1f8",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 90,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "This needs to be called from the consumer thread, not the producing threads that call Subscribe/Unsubscribe\n\nOriginally, I had this executed as part of the below subscribers() method, but this was changed in a previous iteration\n\nWith this approach, it can be called at multiple locations by the consumer, whenever it\u0027s safe.\nFor an example use case of calling it multiple times, compare to socket_handle_waiter.cc which calls handle_deletion_block_.notify_all() at multiple locations (as this method has a comparable unsubscribe_block_.notify_all() call)",
      "parentUuid": "859b3abc_ffe5615d",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b317f042_8f349c09",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 90,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "I think an easier to use API would not require the consumer to call an extra method to update the state of the subscribers, particularly because the consumer may have no idea whether there are any pending calls to Subscribe()/Unsubscribe().\n\nWhat was the disadvantage of putting this call in subscribers()?\n\nIf the concern is that subscribers() is more likely to be called in a \"hot loop,\" then you could use an atomic operation to know whether there are any pending changes, which should be able to implemented in a lock free manner (DCHECK(atomic\u003cbool\u003e::is_lock_free).\n\nAlso do you need strong consistency or eventual consistency?  Does subscribers() always need to see all pending changes, or can they be applied later?\n\nI think whether you break out the method into the API, or call it internally, this object will perform badly if either the producer or consumer hot-loops the API.",
      "parentUuid": "a6236d55_9686b1f8",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb00bccc_0853fd12",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 90,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-15T22:36:52Z",
      "side": 1,
      "message": "Updated the code to use an atomic boolean to eliminate hot loop concerns as suggested - that fixes the Note above. Though, in practice, we don\u0027t expect a hot loop on this method to ever occur\n\nI like the idea of putting it back into subscribers(), though the changes to subscribers can be applied later / eventual consistency is fine\n\nThe main rationale for calling it more frequently is that this method contains the unsubscribe_block_.notify_all(); call, so calling it more frequently means that UnsubscribeBlocking() blocks for less time (see example in above comment for more info)",
      "parentUuid": "b317f042_8f349c09",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84b42db2_c58d937f",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 90,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-10-16T22:12:36Z",
      "side": 1,
      "message": "Per my earlier comments, if there\u0027s a \"hot loop\" problem here (i.e., causing livelock), then the calling code is doing things wrong: It would be adding and removing lots of subscribers, never-ending, and at a very high frequency. The calling code should behave exactly the opposite of that! It should only add/remove one or two subscribers, and only when the user has activated a certain product feature, and certainly never more often than once every few seconds (usually, once per several minutes or more).\n\nI think it\u0027d be best not to over-engineer for a case that should never exist. Extra code, extra potential for bugs or unintended side-effects, fools future developers into thinking a problem exists where there is no problem, etc.",
      "parentUuid": "eb00bccc_0853fd12",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a95b74cf_9b45f925",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Can we adopt abseil-style macros to enforce lock status?\n\nhttps://github.com/abseil/abseil-cpp/blob/master/absl/base/thread_annotations.h#L110\n\nFeel free to file an issue and leave as a TODO.",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce23e729_99d375cc",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Good idea - I hadn\u0027t realized abseil had a thread annotation for method calls\n\nI\u0027ve added an annotation to this method call and removed the comment. Are there any other annotations you would like to see?",
      "parentUuid": "a95b74cf_9b45f925",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6943007_8b5a5a36",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "That looks good.  Feel free to add EXCLUSIVE_LOCKS annotations elsewhere they are suggested by the comments in this patch, and we can annotate existing code later.",
      "parentUuid": "ce23e729_99d375cc",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a4fb12b_8c2cf7f0",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "What is StopProviding?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2934095_010a3ef2",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "Done\n\nComment out of date - updated to UnsubscribeBlocking",
      "parentUuid": "1a4fb12b_8c2cf7f0",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e3089a9_5b5d1f17",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 160,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Is this used?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56309c4b_877b0d08",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 160,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "This is used in MapSubscriberModel below - see line 203\n\nClosing this as it\u0027s duplicated with the below - if we remove MapSubscriberModel, this can be removed",
      "parentUuid": "6e3089a9_5b5d1f17",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cef199a_2ecb8576",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T00:25:51Z",
      "side": 1,
      "message": "Is this used?",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50d6d719_6f2fda86",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-10T18:06:01Z",
      "side": 1,
      "message": "This would be used for storing:\n- std::pair\u003cconst SocketHandle\u0026, SocketHandleWaiter::Subscriber*\u003e objects in SocketHandleWaiter\n- std::pair\u003cStreamSocket*, TlsDataRouterPosix::SocketObserver*\u003e objects in TlsDataRouterPosix\n\nIn these cases, Unsubscribe calls provide us with the Key (either a socket handle or a StreamSocket*), and we need to Unsubscribe the entry associated with that Key and any Value (Equivalent to std::unordered_map::Erase())",
      "parentUuid": "3cef199a_2ecb8576",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3538f15a_d123dc52",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-10-10T20:32:12Z",
      "side": 1,
      "message": "This map (or list of pairs) belong in SocketHandleWaiter/TlsDataRouterPosix, which can look up the subscriber and pass it in here.  This class should be kept simple and does not require key-based lookup.",
      "parentUuid": "50d6d719_6f2fda86",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dca207eb_a1052b93",
        "filename": "util/subscriber_model.h",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-10-15T22:36:52Z",
      "side": 1,
      "message": "Done.\n\nRemoved all map related info, as well as the Equals template parameter\nMy rationale for including it here was to prevent locking entirely in the using classes to keep them simpler :)",
      "parentUuid": "3538f15a_d123dc52",
      "revId": "b0c43c11868051e4d8fcd4e6bf1971aecb2acafd",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}