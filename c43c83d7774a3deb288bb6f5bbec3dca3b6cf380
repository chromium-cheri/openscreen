{
  "comments": [
    {
      "key": {
        "uuid": "7943c510_a2d77c33",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 3
      },
      "lineNbr": 253,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Style #1: Don\u0027t use auto to erase pointers from types.\nStyle #2: Use std::unique_ptr, don\u0027t manually allocate and delete objects.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "087de7c6_918dbefe",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 3
      },
      "lineNbr": 294,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Unwrapping a unique_ptr to pass into an API that then does stuff with the raw pointer is problematic.  Is the raw pointer stored anywhere?\n\nIt would be better to pass socket as a const ref here, but this is optional to fix (as the goal of this patch isn\u0027t to improve EventWaiter per se).",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "838ace2b_9f51ab7b",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 3
      },
      "lineNbr": 324,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "This isn\u0027t an unreasonable transformation by itself, but the goal of adding NetworkRunner or similar would be to _replace_ uses of EventWaiter and things like OnePlatformLoopIteration, not wrap it.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be2b08f3_5136f7de",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 3
      },
      "lineNbr": 324,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T19:30:32Z",
      "side": 1,
      "message": "For this code, I just updating existing code to allow it to continue compiling - I changed EventWaiter to an interface, and these changes are to reflect that change. Once we add the top layer (Network Runner, pending your other CL), the code here will be replaced with calls to that. This work is being tracked by a different item on the task tracking sheet, so I didn\u0027t feel the need to wrap it all up into the same giant CL and just wanted the code to continue functioning for this step",
      "parentUuid": "838ace2b_9f51ab7b",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "646c535d_e07c29ba",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 3
      },
      "lineNbr": 324,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "I agree we should deprecate and remove EventWaiter unless its API proves useful.  It seems reasonable to make this change as an interim step so we can decide later what to do with EventWaiter.",
      "parentUuid": "be2b08f3_5136f7de",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "150d0941_b2f066bb",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Isn\u0027t our goal to get to the point where we use async reads instead of sync waits?  I don\u0027t see what the point of changing this here is when we want to eventually get rid of it (and switch to async read instead of sync wait).  Why don\u0027t we just skip to async read instead of having this in between state?",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 204,
        "endChar": 47
      },
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79307e2b_d7e93009",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 3
      },
      "lineNbr": 204,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T23:12:16Z",
      "side": 1,
      "message": "The in between state is because the CL was getting too large - I don\u0027t want to bundle the entire change into a 2000 line CL or it would take far longer to review, so here I\u0027m just changing the EventWaiter layer to be an object instead of static methods, since the same EventWaiter layer will be a lower-level layer of the Network Waiter. Changes here are just to keep the source compiling during the middle step",
      "parentUuid": "150d0941_b2f066bb",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 204,
        "endChar": 47
      },
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8afdc42_df1e1d2d",
        "filename": "osp/impl/internal_services.h",
        "patchSetId": 3
      },
      "lineNbr": 78,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Please use a std::unique_ptr here.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21064502_ec4b9657",
        "filename": "osp/impl/quic/quic_connection_factory_impl.h",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "std::unique_ptr",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "313f6334_3948fc85",
        "filename": "osp_base/error.h",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Not necessary.  Use `WillOnce(Return(ByMove(...)))`",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bca7a87c_8f096221",
        "filename": "osp_base/error.h",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T19:30:32Z",
      "side": 1,
      "message": "I think I am missing something, and haven\u0027t been able to find a workaround. Using ByMove causes the error:\n\n../../platform/base/network_loop_unittest.cc:199:75: error: call to implicitly-deleted copy constructor of \u0027openscreen::ErrorOr\u003copenscreen::platform::Events\u003e\u0027\n  EXPECT_CALL(mock_waiter, WaitForEvents(timeout)).WillOnce(Return(ByMove(result)));\n                                                                          ^~~~~~\n../../osp_base/error.h:132:3: note: copy constructor is implicitly deleted because \u0027ErrorOr\u003copenscreen::platform::Events\u003e\u0027 has a user-declared move constructor\n  ErrorOr(ErrorOr\u0026\u0026 error_or) \u003d default;\n\nDo you have any intuition on how to fix this?",
      "parentUuid": "313f6334_3948fc85",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bc7f9f0_6d9571b6",
        "filename": "osp_base/error.h",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "The argument to ByMove has to be an rvalue reference.   You need to construct a temporary or use std::move.",
      "parentUuid": "bca7a87c_8f096221",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a952390_150de49f",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "If we\u0027re doing the 2-thread approach, why do we need a mechanism to wake up the NetworkLoop?  Can\u0027t we just have the NetworkLoop run until we shut it down?  I think we only needed that for the 1-thread approach which we decided not to do.\n\nCan you pull the 1-thread (hacky thing) out of this CL?  Perhaps leave it as a pending CL for a while in case we change our minds, but let\u0027s stick with the 2-thread approach for now.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c358b336_4c456803",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T23:12:16Z",
      "side": 1,
      "message": "The reason I added it here was that it was already written by the design review when we decided to make this the \"backup\" approach. Once I had it, I realized we can get better Perf when adding/removing socket callbacks since we can wake the wait loop up instead of waiting for the timeout, and then acquire the mutex more quickly. Happy to pull it out if its a bit too hacky for just a small perf improvement though",
      "parentUuid": "5a952390_150de49f",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c2854e7_aa3c83a8",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "+1 for having a persistent NetworkLoop.  I didn\u0027t follow the comment about needing a timeout for socket callbacks but it may be answered elsewhere in the patch.",
      "parentUuid": "c358b336_4c456803",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "544272d9_3a52deb8",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Also unnecessary.  See ErrorOr comment.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ae3dde6_7a6aefe6",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T19:30:32Z",
      "side": 1,
      "message": "Same issue as on ErrorOr comment",
      "parentUuid": "544272d9_3a52deb8",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43b4f82c_2818400b",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "See comments.  Fixing the unittest will allow this to be removed.   We shouldn\u0027t be changing the semantics of our objects because of unittests.",
      "parentUuid": "0ae3dde6_7a6aefe6",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "078bf772_efa6183a",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "I\u0027m thinking that instead of having a TaskRunner interface and an EventWaiter interface, we should have a NetworkRunner interface that\u0027s a superset of TaskRunner, and not expose any EventWaiter to the users of the API.  I think that would simplify things a lot, especially if we\u0027re doing the 2-thread approach.\n\nAlong with the previous comment, I think we should skip to async reads and not have an in between state before that.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0a9eeca_fdcfdee5",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-29T23:12:16Z",
      "side": 1,
      "message": "I agree that the EventWaiter should not be exposed. \n\nOnce I am back from my OOO I will work on the next steps, pending the open interface CL. Happy to leave this one open indefinitely and not check it in - getting some feedback at this stage will be helpful regardless :)",
      "parentUuid": "078bf772_efa6183a",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "807653ec_e5f71e81",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Again, I agree we should strive to remove EventWaiter, but it depends on whether it\u0027s simpler to make that migration in two stages or one.",
      "parentUuid": "d0a9eeca_fdcfdee5",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5610fe80_bc4835b4",
        "filename": "platform/api/event_waiter.h",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Why not make this std::unique_ptr\u003cEventWaiter\u003e like the comment mentions?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b4c151a_4a556e0b",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Why are you passing a factory function if all you need is a single WakeUpHandler*?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1ad7f69_332fdc93",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Why not unique_ptr?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c2ee854_042226bf",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "nit: remove inconsistent use of `this-\u003e`.",
      "range": {
        "startLine": 30,
        "startChar": 35,
        "endLine": 30,
        "endChar": 39
      },
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e365f96_c71abd8a",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "We should probably put in the documentation somewhere that there can only be one callback per socket.  And should we return an error here if there\u0027s already one?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89cdaa44_e18e2686",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Also please use insert+move here instead of allocation and assignment.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b07775a_b6152cae",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Similar comment as above.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51a6c094_2e47db86",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 57,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Passing in the ctor would avoid this error condition.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecd7d48f_f4400518",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Does the default ctor for ErrorOr already do this?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd1898e4_e26f6ab2",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Let\u0027s not use two locks in this class.  That adds risk of deadlock with no clear benefit.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73f500aa_3978f1f1",
        "filename": "platform/base/network_loop.cc",
        "patchSetId": 3
      },
      "lineNbr": 106,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Rather than have the network loop allocate memory for each packet read, it is going to be much more efficient to have the socket own a circular buffer that it allocates once and appends data to.  The callback would then pass a pointer and length which the Quic implementation would use to consume the data read (copying it out of the buffer).\n\nAgain, not sure this can be fixed without reimplementing UdpSocket.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84b9f9d6_0605e69e",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 1,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "s/2018/2019/ here and elsewhere for new files",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e44bb721_1e7354cb",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Nit: I would expect this to be defined in udp_socket.h, not here.  If that creates circular includes, a separate file like network_constants.h would be an option.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "836674ef_c6ede40e",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Please make this move-only so it can only be owned and invoked once.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb3b999f_9b002582",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Allocating 64K for the read callback is not efficient since we should avoiding datagram fragmentation and only sending datagrams that are less than the path MTU.\n\nQUIC actually mandates this: https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#rfc.section.14\n\nThe more correct thing to do is to query each socket for path MTU and allocate the read callback size to match.  But in the absence of that, we should probably assume the QUIC packet sizes in the spec.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "825cf5cb_4da7674d",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Would it make sense to do this instead?\n\nOnRead(Packet* data, UdpSocket* socket, NetworkLoop* network_runner);\n\nThat way you don\u0027t have a packet.socket, which is kind of a weird thing.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8fd90cc_919cb052",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Isn\u0027t this in Brandon\u0027s CL?  Will this be removed when you rebase?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3135f4d7_f6ee877c",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "Please make this move-only (see comment re: UdpReadCallback)",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71de6622_6e54aaf5",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Shouldn\u0027t this be an implementation of NetworkRunner (a superser of TaskRunner with an async read method)?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6844863c_dce2a26e",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 64,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Can we have this CL stick to just reading and not writing?  I think writing could be done synchronously (or fake synchronously like we did in Chromium already).  The QUIC code expects synchronous writes.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbe812b0_65bf8db6",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Why is this a setter instead of taking it in the constructor?  Would you ever change it?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "388c97af_8d696e21",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Why is this public?  If it\u0027s just for tests, can you call it XForTesting?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "415aa161_b6ed5acd",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 76,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "As mentioned, I don\u0027t think we need this.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ea15c0a_332d1c62",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 84,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Can you make the members private and limit what is protected?",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6100aeb9_850c85fc",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-05-30T23:50:37Z",
      "side": 1,
      "message": "I would rather structure the code so that callbacks can be registered with the sockets directly instead of being maintained in separate data structures.  Since this code is part of platform/base what is the concern with having the socket API depend on it?\n\nWe may need to split the socket implementation into a base implementation and a backend which can be implemented embedder-side for the platform-specific code.  If it requires major surgery, then it\u0027s probably best to discuss further and implement in a separate patch.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73e99f8b_ed486dca",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 96,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "Missing trailing underscore.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d3c5bd7_b9f6d093",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-29T02:53:05Z",
      "side": 1,
      "message": "extra preposition",
      "range": {
        "startLine": 101,
        "startChar": 13,
        "endLine": 101,
        "endChar": 16
      },
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b82d23f_9b12171a",
        "filename": "platform/base/network_loop.h",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:28:30Z",
      "side": 1,
      "message": "Two locks always scares me.  Plus, we don\u0027t really need the writing one, so another reason to stick with reading in this CL.",
      "revId": "c43c83d7774a3deb288bb6f5bbec3dca3b6cf380",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}