{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "de648add_fa71a8ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-03-15T01:44:00Z",
      "side": 1,
      "message": "Lemme know if you have any suggestions for test coverage. I\u0027ll take a look at adding some tests to the receiver tomorrow morning.",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c35f8973_f737c6a0",
        "filename": "cast/streaming/clock_drift_smoother.cc",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2022-03-15T17:37:07Z",
      "side": 1,
      "message": "This could be \u003c\u003d instead of \u003c, but with the logic you added you will still end up calling Reset() even if now \u003d\u003d last_update_time_.",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea6606b7_67d8e7b4",
        "filename": "cast/streaming/clock_drift_smoother.cc",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-03-15T18:24:25Z",
      "side": 1,
      "message": "The clock only has to be monotonically non-decreasing, so it\u0027s not actually an error if now \u003d\u003d last_update_time_, but if now \u003c last_update_time_ that should be a DCHECK at least.",
      "parentUuid": "c35f8973_f737c6a0",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6309d721_6dd396c0",
        "filename": "cast/streaming/receiver_base.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2022-03-15T17:37:07Z",
      "side": 1,
      "message": "FYI, I didn\u0027t see a usage example?",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d1d2d11e_a799fdac",
        "filename": "cast/streaming/receiver_base.h",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-03-15T18:24:25Z",
      "side": 1,
      "message": "Good point, I\u0027ll update to be accurate.",
      "parentUuid": "6309d721_6dd396c0",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66d07efb_26ca7506",
        "filename": "cast/streaming/receiver_base.h",
        "patchSetId": 3
      },
      "lineNbr": 102,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2022-03-15T17:37:07Z",
      "side": 1,
      "message": "Well the default was definitely too low as a 60Hz display will need at least 16ms to wait for vsync for the frame to appear.\n\nI\u0027d like to understand better whose job it is to schedule the frame to appear at its intended playout time; I don\u0027t see any playout timestamp data being propagated through this API so is that libcast\u0027s job?\n\nNote that increasing this constant beyond its actual, real-world value will reduce the time window for receiving retransmissions, so there will be more skipped frames in poor network conditions.  Ideally this would be set to the actual value for the implementation so the retransmission window can be maximized.",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20c728cf_a4ab3fc7",
        "filename": "cast/streaming/receiver_base.h",
        "patchSetId": 3
      },
      "lineNbr": 102,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2022-03-15T18:24:25Z",
      "side": 1,
      "message": "1000% agree, there is some followup work here to do in the components/cast_streaming code to actually call SetPlayerProcessingTime(). Let\u0027s follow up over email on that.\n\nIt\u0027s the client\u0027s job to use the EncodedFrame::reference_time value to schedule playback. We currently use the rtp_timestamp instead which might be contributing to these issues.\n\nLibcast primarily uses the processing time to determine if the frame might be late--clients can take ownership of the frame the moment all of its packets come in.\n\n\nFinally, did some more testing and looks like 100ms is on the higher side, so to be safe we can probably settle on more like 50ms.",
      "parentUuid": "66d07efb_26ca7506",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d5f0d1a_e1b32da6",
        "filename": "cast/streaming/receiver_base.h",
        "patchSetId": 3
      },
      "lineNbr": 102,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2022-03-15T20:29:44Z",
      "side": 1,
      "message": "Sounds good, let\u0027s follow up over email.  Understanding the algorithms setting the reference_time and rtp_timestamp would be helpful.\n\nFor iOS, I set rtp_timestamp from the sender\u0027s presentation timestamp passed in to the library, but I didn\u0027t dig further to find out where that timestamp came from.",
      "parentUuid": "20c728cf_a4ab3fc7",
      "revId": "fbc040c842d87cfa8854e1a4538db58111152777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}