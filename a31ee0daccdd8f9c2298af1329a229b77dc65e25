{
  "comments": [
    {
      "key": {
        "uuid": "1a982f4f_d85c0b29",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T17:12:56Z",
      "side": 1,
      "message": "Ok to add a possibly-closed socket here?",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dabb7b62_b45e1201",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "That depends on the error-handling CL\n\nBased on Yuri\u0027s suggestion, sockets that are in a bad state (ie failed a Bind() call) will fail any future calls\n\nIf we want to maintain parity with the current code, we could make the OnError(...) code have an OSP_ASSERT(false) to crash the demo as done now, but I did not see the issue in having a different sort of failure case (which might give us more info and help debugging) as long as the failure is logged. At least since this is intended to be a test demo\n\nThoughts?",
      "parentUuid": "1a982f4f_d85c0b29",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9eb930c6_a92e0429",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T18:38:35Z",
      "side": 1,
      "message": "Ok, if the mDNSResponder wants to rebind the same interface in the future, then it will need to check subsequent operations for errors.  Does mDNSResponder treat read or write errors as permanent, or will it retry them endlessly?",
      "parentUuid": "dabb7b62_b45e1201",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbe62e2d_c80e7809",
        "filename": "osp/impl/discovery/mdns/embedder_demo.cc",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T20:05:04Z",
      "side": 1,
      "message": "After thinking a bit more, I think maintaining parity might make more sense\n\nWe are currently in the process of swapping out our mDNS library, so I don\u0027t think it makes much sense to put that much time into designing around the old approach\n\nI\u0027ve changed the code to crash the demo if an error occurs (as it did before), but please let me know if you prefer the other approach and I can change back.",
      "parentUuid": "9eb930c6_a92e0429",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82878e5a_c1cf9a24",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 2
      },
      "lineNbr": 154,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T17:12:56Z",
      "side": 1,
      "message": "This is now always going to return true, which means that OSP will attempt MDNS on every interface (regardless of whether it was successfully bound or not).\n\nThe socket registration code should go into the OnError callback.",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4bcad929_dd28a5a1",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 2
      },
      "lineNbr": 154,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "My initial approach was assuming we would be adding Error Handling similar to what Yuri described during the design review - where methods called on an \"unhealthy\" socket return immediately. If we don\u0027t want to rely on this, I am happy to go with your idea\n\nThe issue with the approach you suggest is that the callback, based on the current design, is only called when an error occurs. So the registration would only be called for errors. Additionally, the same callback is used for all configuration errors, where one might be okay and another fails. The approach I see working is:\n  1) Call RegisterMdnsSocket(...) on a new socket\n  2) Then call SetUpMulticastSocket(socket.get(), index)\n  3) In the OnError callback, we call parent_-\u003eDeregisterMdnsSocket(...)\nIf we try to call RegisterMdnsSocket(...) after SetUpMulticastSocket(...), we are introducing a race condition if these methods get called on any thread aside from the task runner, which is why I have 1 before 2.\n\nIf this doesn\u0027t work, we might need to revisit the design\n\nThoughts?",
      "parentUuid": "82878e5a_c1cf9a24",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32759378_8dd5329c",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 2
      },
      "lineNbr": 154,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T18:38:35Z",
      "side": 1,
      "message": "I thought OnError could be called with Error::Code::Ok.  (Maybe we should rename Error to Result, but that\u0027s different discussion).\n\nI think the socket has to be bound before it\u0027s registered; registering tells the mDNSResponder that it\u0027s ready for read/write.\n\nDeregistering the socket in the OnError callback sounds good.\n\nI assumed that all of these methods would get called on the task runner to guarantee sequencing of callbacks and allow them to modify state in the client without locks.  What threading model were you thinking of for socket clients?",
      "parentUuid": "4bcad929_dd28a5a1",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59181a26_7383b5d1",
        "filename": "osp/impl/internal_services.cc",
        "patchSetId": 2
      },
      "lineNbr": 154,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T20:05:04Z",
      "side": 1,
      "message": "I was under the impression that the embedder would be calling this method, but looking more through the code I see I am wrong - that simplifies things a lot\n\nUpdating the code to deregister the socket when an error comes in\n\nI\u0027ll open a new comment to discuss whether we want to call OnError (or whatever we rename it to) on all responses or just errors",
      "parentUuid": "32759378_8dd5329c",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "21efe2a7_088d5965",
        "filename": "osp/impl/quic/quic_connection_factory_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T17:12:56Z",
      "side": 1,
      "message": "How will you know if the socket was bound successfully at this point?\nThis needs to move to OnError.",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bcbf3675_8cbbe44b",
        "filename": "osp/impl/quic/quic_connection_factory_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "This has the same issues as discussed in the above approach. \n\nHow about:\n  1) Add all newly created sockets to the sockets_ list\n  2) call server_socket-\u003eBind() (and similar configuration methods)\n  3) the OnError(...) removes from sockets_\nwith a lock around sockets_ access just to be safe\n\nThoughts?",
      "parentUuid": "21efe2a7_088d5965",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3061fd6f_c68558a8",
        "filename": "osp/impl/quic/quic_connection_factory_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T18:38:35Z",
      "side": 1,
      "message": "That would work, but I would rather not have a lock around sockets_.\n\nMaybe we can land your change to close sockets on error and use that as a signal for callers to update their bookkeeping.\n\nIf the bind fails, when does the socket get removed from the network runner?",
      "parentUuid": "bcbf3675_8cbbe44b",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "409a4d61_5bd499fa",
        "filename": "osp/impl/quic/quic_connection_factory_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T20:05:04Z",
      "side": 1,
      "message": "If we can guarantee that this class\u0027s code only gets called from the Task Runner, then we won\u0027t need the lock - It looks like we don\u0027t have this guarantee currently though (the Demo calls QuickServer::Start() / QuickClient::Start() which then call QuicConnectionFactory::SetServerDelegate(...) which touches sockets_), but if not it wouldn\u0027t be hard to add by pushing to the task runner first.\nAlternatively, we could use a concurrent, non-locking hashset implementations to store sockets_ - but this would involve either taking another 3rd party dependency or re-implimenting one ourselves\n\nI like your idea though! We currently don\u0027t remove from the NetworkRunner until socket destruction (via the deletion_callback_), but it would make sense that if a socket enters an error state (ie bind fails) then it gets called.\nI\u0027ll focus on the error handling approach for now, but let me know if you\u0027d prefer one of the other options",
      "parentUuid": "3061fd6f_c68558a8",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "502997be_69b2909f",
        "filename": "platform/impl/udp_socket_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-19T22:23:27Z",
      "side": 1,
      "message": "Maybe make this a lambda? and use it here and at other call sites?",
      "range": {
        "startLine": 140,
        "startChar": 4,
        "endLine": 141,
        "endChar": 80
      },
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb529688_e0e22747",
        "filename": "platform/impl/udp_socket_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-08-20T17:12:56Z",
      "side": 1,
      "message": "Please remove debugging code before submitting here and below.",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0302dca8_fae61215",
        "filename": "platform/impl/udp_socket_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "The code to return the strerror(errno) was actually already here\n\nThe changes here were intended to be perminant, not just for testing - this way, we maintain parity on the information currently logged in the case of a bind failure (which usually includes the endpoint being called)\n\nI can remove it if you feel this info isn\u0027t useful though",
      "parentUuid": "eb529688_e0e22747",
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ed5d06e_74fb0c3e",
        "filename": "platform/impl/udp_socket_posix.cc",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "Good idea. Done\n\nWaiting on pushing a new iteration until some other comments are discussed, so this will show up next iteration",
      "parentUuid": "502997be_69b2909f",
      "range": {
        "startLine": 140,
        "startChar": 4,
        "endLine": 141,
        "endChar": 80
      },
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0c8ec3c9_49576bbd",
        "filename": "platform/test/mock_udp_socket.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-19T22:23:27Z",
      "side": 1,
      "message": "Would it make sense to have a common queue of errors for all methods to use, not just Bind()?",
      "range": {
        "startLine": 63,
        "startChar": 20,
        "endLine": 63,
        "endChar": 32
      },
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e98c714c_90356277",
        "filename": "platform/test/mock_udp_socket.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-20T18:17:41Z",
      "side": 1,
      "message": "My plan was to have a separate queue for each. In UTs, it would be much clearer if we set them individually\n\nPTAL at the Write CL though - I use a similar approach in real UTs which may show why I want this approach",
      "parentUuid": "0c8ec3c9_49576bbd",
      "range": {
        "startLine": 63,
        "startChar": 20,
        "endLine": 63,
        "endChar": 32
      },
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b42af5e7_38f50cf5",
        "filename": "platform/test/mock_udp_socket.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-20T19:25:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e98c714c_90356277",
      "range": {
        "startLine": 63,
        "startChar": 20,
        "endLine": 63,
        "endChar": 32
      },
      "revId": "a31ee0daccdd8f9c2298af1329a229b77dc65e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}