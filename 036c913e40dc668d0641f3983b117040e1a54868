{
  "comments": [
    {
      "key": {
        "uuid": "2e41abb9_26a720e5",
        "filename": "discovery/mdns/mdns_probe.cc",
        "patchSetId": 3
      },
      "lineNbr": 41,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "std::move() all the way through",
      "range": {
        "startLine": 41,
        "startChar": 32,
        "endLine": 41,
        "endChar": 46
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3271a1f_48cce2cb",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 28,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-02T18:31:56Z",
      "side": 1,
      "message": "Since this class is a one-shot API, this is really a Callback object that is curried through the constructor.  Suggest renaming to Callback.",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49921ef0_3741e539",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "How does MdnsProbe communicate that we _cannot_ take ownership of |requested_name|?  It looks like MdnsPublisher would currently leak MdnsProbe in that case.  However, ClaimExclusiveOwnership has a comment saying this could end up being a \"similar\" name.  Does MdnsProbe also handle retrying with different names then (i.e. section 9 of the RFC)?  If so, I wonder whether it\u0027s better to let the caller handle renaming based on other information it might have, but I don\u0027t have much to go on so I don\u0027t feel strongly.  Also, if that\u0027s the case, it might be beneficial for the class comment to say that it implements sections 8 and 9.",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a4547302_1922fa29",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-12-06T17:17:06Z",
      "side": 1,
      "message": "\u003e Does MdnsProbe also handle retrying with different names then (i.e. section 9 of the RFC)?\n\nThis is what I had planned. for our use case, we expect that all records will be using the same domain name (something to the effect of \"instance._castv2._udp.local\"), because we will only have one SRV record. In this case, we\u0027d only need to ever change \u0027instance\u0027 to \u0027instance#\u0027 for some number, which seems reasonable enough for us to make assumptions about\n\nWill add comments to this affect if it sounds good to you",
      "parentUuid": "49921ef0_3741e539",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbc480a7_b6123b2a",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "It\u0027s pretty hard to tell if passing this by value is the right choice; can you briefly explain why this over const-ref?",
      "range": {
        "startLine": 32,
        "startChar": 49,
        "endLine": 32,
        "endChar": 64
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9cbcd6b_ca899d12",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-02T18:31:56Z",
      "side": 1,
      "message": "I don\u0027t follow why this method takes a vector of functors.  What are record_factories going to be used for?",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74bc73f1_c296875a",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-12-04T01:09:45Z",
      "side": 1,
      "message": "According to RFC6762 section 8.2\n\"each host populates the query message\u0027s Authority Section with the record or records with the rdata that it would be proposing to use, should its probing be successful.\" - the factorioes are used to populate these authority records\n\nAn alternative would be to expect the caller to provide an IPEndpoint (for one of their Instance\u0027s endpoints) instead of the functors. Then, we internally use that to create an A / AAAA record, and we can use that for tie breaking in the probing step (as described in the RFC). Then, once the name is claimed, the caller registers all records they care about separately. Does this sound better to you?\nIt wouldn\u0027t be fully to spec, but I can\u0027t see any issues arising from this based on my reading of the RFC",
      "parentUuid": "d9cbcd6b_ca899d12",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b228fcfa_ed7ee873",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "It\u0027s still not clear to me why this couldn\u0027t be std::vector of MdnsRecord* or Rdata*?  The probe is basically an initialization step, so there shouldn\u0027t be much of a long-term lifetime concern, correct?  The vector could also be by-value if absolutely necessary.  Can you give an example call sequence whether the factory form is better/necessary?  It seems like the records are known starting from ClaimExclusiveOwnership, where the MdnsProbe is created, and then they are committed or dropped in OnDomainFound, where MdnsProbe is destroyed.\n\nFor the IPEndpoint suggestiong: I could be misremembering how mDNS labels things, but isn\u0027t it true that for DNS-SD SRV/TXT are under one name (instance name) and A/AAAA are under another (hostname)?  If that\u0027s true, only checking hostname seems problematic.",
      "parentUuid": "74bc73f1_c296875a",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3da6316_e4705e47",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-12-06T17:17:06Z",
      "side": 1,
      "message": "\u003e It\u0027s still not clear to me why this couldn\u0027t be std::vector of MdnsRecord*\n\nThe probe is an intialization step, but we can\u0027t initialize with just the MdnsRecord because one parameter of the MdnsRecord is the DomainName (field name). When running the probing phase, we first try and claim the requested name (lets say \"instance._castv2._udp.local\"). If that fails, we modify the provided name according to the process supplied in RFC 6762 and 6763 (so if \"instance._castv2._udp.local\" is already claimed, we might instead try \"instance2._castv2._udp.local\"). At this point, the original MdnsRecord would be invalid, since it is created with the wrong DomainName. We need these records to be accurate, because we are using them for collision detection, so we need a mechanism to modify the name field. For this purpose, we use a factory.\n\n\u003e or RData\n\nThe issue with this approach is that we lose the TTL information supplied by the caller. For the probe phase this may not matter (what does everyone else think?) though so it could work ðŸ˜ŠThis would require that registration of records is done as a separate step after the probe phase, but I still think this would end up cleaner\n\n\u003e For the IPEndpoint suggestiong: I could be misremembering how mDNS labels things, but isn\u0027t it true that for DNS-SD SRV/TXT are under one name (instance name) and A/AAAA are under another (hostname)?  If that\u0027s true, only checking hostname seems problematic.\n\nYou are correct that SRV and TXT records use one name and A/AAAA records use a (possibly) different name, the one called out in the SRV record\u0027s RData. That being said, there is no reason we need to probe for these 2 domains at once or with the record type that we expect will be using that domain name.\n\nLet\u0027s say we care about domain d1, ..., dn where each is used by a TXT, SRV, A, or AAAA record. Then, we can spin up probes P1, ... Pn where Pi is associated with di. In each of these probe steps, we would supply an A or AAAA record, even if that\u0027s not the record type we plan to create at the end. Because RFC 6762 calls out that probe queries are done using DnsType::kANY, even if these are not the final record types, they will still match the incoming query and conflict resolution can proceed as described in the RFC. Then, after conflict resolution is completed and the probe\u0027s callback is called, we can register all records with the new name using the RegisterRecord call in MdnsPublisher. The only edge case here is if the same IPendpoint is used for multiple Probe queries, but:\n- For different instances, this should never happen (they can never share an IP endpoint per RFC)\n- For the same endpoint, this would be considered \u0027redundant\u0027 records per RFC 6762 and would be a non-issue\n\nThis would require n separate probe queries, but given that n \u003c\u003d 2 for all current cases (the instance for castV2 and for OSP, since we will be using the same instance domain name for A and AAAA records, as we only publish one SRV record), that shouldn\u0027t be a problem\n\nIf this approach seems to at least *sound* better than the original one, I can update this CL to reflect the suggestion above. IMHO it would be much cleaner, but would require significant documentation",
      "parentUuid": "b228fcfa_ed7ee873",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d41ec6f6_5a83e31b",
        "filename": "discovery/mdns/mdns_probe.h",
        "patchSetId": 3
      },
      "lineNbr": 47,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-06T17:23:01Z",
      "side": 1,
      "message": "It seems like the caller must have already generated the records it intends to announce before it is ready to probe, and alterations to those records aren\u0027t required.  In that case it can pass them as const std::vector\u003cMdnsRecord\u003e\u0026.\n\nIf a conflict is detected, I would leave it up to the caller to generate new records with new names and then probe again.",
      "parentUuid": "b228fcfa_ed7ee873",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d7f0cf6_bb57eea5",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 53,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "std::move()",
      "range": {
        "startLine": 53,
        "startChar": 18,
        "endLine": 53,
        "endChar": 26
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4be79030_ee80d865",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-02T18:31:56Z",
      "side": 1,
      "message": "I don\u0027t think this layering is quite right. The MdnsProbe class should be responsible for tracking outstanding probes, using an internal struct if needed; versus adding those implementation details to the publisher.\n\nThe publisher should only have to call\n\nprobe_.ClaimDomainName(target_name, callback)\n\nto start a probe that invokes |callback| when complete.",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0038cdb_db3634b8",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-12-04T01:09:45Z",
      "side": 1,
      "message": "See above comment - We need more data than that to satisfy RFC 6762 section 8.2\u0027s requirements",
      "parentUuid": "4be79030_ee80d865",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b985c27_134e1f39",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-06T17:23:01Z",
      "side": 1,
      "message": "Right, but the argument I had before still applies.  The prober class could keep track of the records in the probe.",
      "parentUuid": "f0038cdb_db3634b8",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "999f87b5_df913f13",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 57,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "std::move()",
      "range": {
        "startLine": 57,
        "startChar": 39,
        "endLine": 57,
        "endChar": 55
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "833f8716_8d38eb53",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 96,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "std::move()",
      "range": {
        "startLine": 96,
        "startChar": 18,
        "endLine": 96,
        "endChar": 30
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e26e696_cc011b68",
        "filename": "discovery/mdns/mdns_publisher.cc",
        "patchSetId": 3
      },
      "lineNbr": 100,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-12-05T23:34:26Z",
      "side": 1,
      "message": "std::move()",
      "range": {
        "startLine": 100,
        "startChar": 13,
        "endLine": 100,
        "endChar": 17
      },
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "029927cb_3bd8b5a0",
        "filename": "discovery/mdns/mdns_publisher.h",
        "patchSetId": 3
      },
      "lineNbr": 54,
      "author": {
        "id": 1001982
      },
      "writtenOn": "2019-12-02T18:31:56Z",
      "side": 1,
      "message": "Rather than have a separate functor argument here vs. the Callback object in MdnsProbe, can they be combined into a DomainNameCallback type?",
      "revId": "036c913e40dc668d0641f3983b117040e1a54868",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}