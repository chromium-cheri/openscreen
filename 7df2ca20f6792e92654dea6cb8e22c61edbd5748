{
  "comments": [
    {
      "key": {
        "uuid": "c331ae68_d7139285",
        "filename": "platform/base/network_socket_watcher.h",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-02T23:11:23Z",
      "side": 1,
      "message": "In the design doc, we are calling the callback on the read data, instead of on the socket:\n\nReceivedData data;\n    ev.socket-\u003eReadMessage(\u0026data-\u003ebytes[0], data-\u003ebytes.size(), \u0026data-\u003esource,\n        \u0026data-\u003eoriginal_destination);\n    auto entry \u003d read_callbacks_.find(ev.socket);\n    if (entry !\u003d read_callbacks_.end()) {\n      entry-\u003esecond-\u003eOnRead(data);\n    }\n\n\nWhat are your thoughts on going this route instead? If we\u0027re calling it on the socket, I worry it may not actually get read before the next iteration of the Wait(...) method gets calls, and a read from the same socket will get queued twice\n\nSimilar comment for write",
      "range": {
        "startLine": 20,
        "startChar": 26,
        "endLine": 20,
        "endChar": 43
      },
      "revId": "7df2ca20f6792e92654dea6cb8e22c61edbd5748",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30d6bfa8_e028207c",
        "filename": "platform/base/network_socket_watcher.h",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-03T00:54:27Z",
      "side": 1,
      "message": "You\u0027re right, I changed the API but didn\u0027t change the implementation example.  The reason it was changed was to avoid having to decide on a buffer size/allocation point.  This is probably even more important in the TCP case where there is not a clear \"packet\" size to use.",
      "parentUuid": "c331ae68_d7139285",
      "range": {
        "startLine": 20,
        "startChar": 26,
        "endLine": 20,
        "endChar": 43
      },
      "revId": "7df2ca20f6792e92654dea6cb8e22c61edbd5748",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "569b5b1d_00d45f74",
        "filename": "platform/base/network_socket_watcher.h",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-03T03:07:58Z",
      "side": 1,
      "message": "With this approach, wouldn\u0027t we have to run the callback on the network thread instead of queuing it on the Task Runner as originally planned? Does this mean we\u0027re assuming that the callback is only going to do trivial work (ie read the data then throw another function on the task queue itself)? \n\nMy original thought had been to use std::bind(this, ReadData) to create a Task\u003dfunction\u003cvoid()\u003e with the callback and read data, then throw it on the Task queue for processing, so the absolute minimal time would be used before proceeding. With this approach we can no longer do that, and any callbacks need to be completed before we can exit after a WakeUp() call, so it might introduce some jitter in playback if the callbacks arent sufficiently simple",
      "parentUuid": "30d6bfa8_e028207c",
      "range": {
        "startLine": 20,
        "startChar": 26,
        "endLine": 20,
        "endChar": 43
      },
      "revId": "7df2ca20f6792e92654dea6cb8e22c61edbd5748",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}