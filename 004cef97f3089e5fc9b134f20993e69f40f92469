{
  "comments": [
    {
      "key": {
        "uuid": "83f65ac0_6756ba14",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T21:44:11Z",
      "side": 1,
      "message": "to ensure thread safety, use:\nbool was_running \u003d is_running.exchange(true)\nOSP_DCHECK(!was_running)",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 53,
        "endChar": 21
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb3ebab4_ecefa2ec",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T23:37:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "83f65ac0_6756ba14",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 53,
        "endChar": 21
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dae78821_fb849487",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-09-24T23:51:08Z",
      "side": 1,
      "message": "I don\u0027t see much point in using unique_lock here since you manually call lock and unlock anyway.\n\nMaybe like this?\n\nbool more_tasks \u003d true;\nwhile (more_tasks)\n{\n  task_mutex_.lock();\n  running_tasks_.swap(tasks_);\n  task_mutex_.unlock();\n\n  more_tasks \u003d !running_tasks_.empty();\n  RunRunnableTasks();\n}",
      "range": {
        "startLine": 66,
        "startChar": 4,
        "endLine": 73,
        "endChar": 5
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66bb80e5_4834703d",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-09-24T23:51:08Z",
      "side": 1,
      "message": "Um, a task can reschedule itself without a delay (or, a more realistic scenario, a task loop that keeps itself alive). It\u0027s a bad, very bad task, and we don\u0027t want tasks like that, but it would be great to be able to mitigate it somehow.",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 73,
        "endChar": 5
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f673532_0c45faaa",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T21:44:11Z",
      "side": 1,
      "message": "Probably good to also DCHECK it was running prior to this call",
      "range": {
        "startLine": 80,
        "startChar": 22,
        "endLine": 80,
        "endChar": 42
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a02bf561_128c3706",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-09-24T23:51:08Z",
      "side": 1,
      "message": "This is very elegant and I like it.",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 46
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9127789e_9ee5f8f4",
        "filename": "platform/impl/task_runner.cc",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-09-24T23:51:08Z",
      "side": 1,
      "message": "Maybe change this to WaitForRunnableTasks() and call RunRunnableTasks() independently? I think it makes a bit clearer what\u0027s going on.\n\nwhile (is_running_) {\n  ScheduleDelayedTasks();\n  WaitForRunnableTasks();\n  RunRunnableTasks();\n}",
      "range": {
        "startLine": 83,
        "startChar": 21,
        "endLine": 83,
        "endChar": 41
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c84f7b65_504abc98",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T21:44:11Z",
      "side": 1,
      "message": "why not an atomic? After this change, we expect RunUntilStopped to be called from the embedder thread and then this bool changed by RequestStopSoon from the TaskRunner thread",
      "range": {
        "startLine": 124,
        "startChar": 2,
        "endLine": 124,
        "endChar": 6
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f880b441_dc171625",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1323871
      },
      "writtenOn": "2019-09-24T21:51:34Z",
      "side": 1,
      "message": "RunUntilStopped blocks the current thread, so it has be called from a shiny new TaskRunner thread, right? This is the same thread that tasks get posted to, if I understand correctly, so the stop task should run on the same thread RunUntilStopped is called on.",
      "parentUuid": "c84f7b65_504abc98",
      "range": {
        "startLine": 124,
        "startChar": 2,
        "endLine": 124,
        "endChar": 6
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3883f22_6a6bd896",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T21:57:33Z",
      "side": 1,
      "message": "Due to data caching, the value of is_running_ may not by synced between multiple threads if it is not stored in an atomic_bool\n\nAlso, our design does not prevent starting a task runner after it has been stopped. That is a valid approach that may lead to concurrent access or modification",
      "parentUuid": "f880b441_dc171625",
      "range": {
        "startLine": 124,
        "startChar": 2,
        "endLine": 124,
        "endChar": 6
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e3de7e6_6be7dce8",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-09-24T23:03:43Z",
      "side": 1,
      "message": "\u003e why not an atomic?\n\nNo need for the atomic since only one thread can possibly read/write to |is_running_|. In fact, to be even more constrained in describing this restriction, note that |is_running_| will only be read/written while RunUntilStopped() is on the call stack. There is no other way to reach it.\n\n\u003e After this change, we expect RunUntilStopped to be called from the embedder thread and then this bool changed by RequestStopSoon from the TaskRunner thread\n\nNote that RequestStopSoon() doesn\u0027t read nor mutate |is_running_|. Instead, it posts a task that will be executed from the loop in RunUntilStopped().\n\n\u003e RunUntilStopped blocks the current thread, so it has be called from a shiny new TaskRunner thread, right?\n\nThe application developer can choose to dedicate any thread to being the \"task runner loop.\" That could be \"main()\" or a separate thread started by the app for this purpose. This behavior isn\u0027t being changed by this patch...we\u0027ve always had it this way.\n\n\u003e This is the same thread that tasks get posted to, if I understand correctly, so the stop task should run on the same thread RunUntilStopped is called on.\n\nYes, that\u0027s correct. And, the stop task must be run from a call stack that includes RunUntilStopped(), since that\u0027s the loop that spins to take tasks out of the queue and run them.",
      "parentUuid": "e3883f22_6a6bd896",
      "range": {
        "startLine": 124,
        "startChar": 2,
        "endLine": 124,
        "endChar": 6
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8b8528b_ff268296",
        "filename": "platform/impl/task_runner.h",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-09-24T23:37:17Z",
      "side": 1,
      "message": "Discussed offline and resolved",
      "parentUuid": "6e3de7e6_6be7dce8",
      "range": {
        "startLine": 124,
        "startChar": 2,
        "endLine": 124,
        "endChar": 6
      },
      "revId": "004cef97f3089e5fc9b134f20993e69f40f92469",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}