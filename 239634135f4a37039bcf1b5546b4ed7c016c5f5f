{
  "comments": [
    {
      "key": {
        "uuid": "ea387b62_1fdbb8e0",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-08T21:47:28Z",
      "side": 1,
      "message": "After substantial changes that you\u0027ve made there\u0027s one thing that\u0027s quite easy to spot here.\n\nYou always allocate enough space on stack for SynchronousTraceLogger + is_initialized field, and then possibly construct SynchronousTraceLogger or use a dummy in that space.\n\nIf you\n1) move is_initialized into SynchronousTraceLogger (or one of the base classes)\n2) add a constructor with an empty parameters list (i.e. SynchronousTraceLogger()) that sets is_initialized to false.\n\nThen SynchronousTraceLogger can be it\u0027s own uninitialized dummy when trace logging is off.\n\nYou don\u0027t need TraceCreationHelper, don\u0027t need ScopedStackStorage, and as far as I can tell, don\u0027t even need a virtual destructor.\n\nThis applies to other places where TraceCreationHelper is used.",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fcaa55b9_7e6e3b81",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-08T21:54:25Z",
      "side": 1,
      "message": "I discussed this with Yuri as well. Some of the downsides of this approach are:\n1) With the current approach, the parameters to the TRACE_SCOPED(...) call are only evaluated if TraceLogging is enabled. Else, it\u0027s just a stack allocation which only moves the stack pointer - effectively a no-op\n2) The approach you\u0027re suggesting would still incur costs associated with calling virtual methods/constructors/etc. It may not actually end up doing anything, but there are more than a few extra calls\n\nIf this weren\u0027t a place we needed the absolute maximum speed possible, I\u0027d agree. But the approach taken here is helpful in minimizing the amount of time taken when tracing isn\u0027t enabled - no extra calls, parameters aren\u0027\u0027t evaluated, just IsTracingEnabled() and moving the stack pointer\n\nThe virtual destructor I need for other reasons - the constructor and destructor of the base class are where pushes to the traces_ stack occur, in the base class.",
      "parentUuid": "ea387b62_1fdbb8e0",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "042c5e26_243f7f19",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-08T22:07:48Z",
      "side": 1,
      "message": "1) It would not\n\nconst auto TRACE_INTERNAL_UNIQUE_VAR_NAME(trace_ref_) \u003d TRACE_IS_ENABLED(category) ? SynchronousTraceLogger(category, name, __FILE__, __LINE__, ##__VA_ARGS__) : SynchronousTraceLogger();\n\n2) That would be a lot of code to put into CR comments, but if you define \"no-op\" constructors in base classes, then calling SynchronousTraceLogger() wouldn\u0027t do anything except setting is_initialized to false.\nAs for the calls to the virtual methods - you incur them anyway when you call those methods.\n\nYour scoped local variable does not have to be of the base type, it can be SynchronousTraceLogger, which means you don\u0027t actually need virtual methods.\n\n\u003eIf this weren\u0027t a place we needed the absolute maximum speed possible\nAnd yet there are virtual functions and a virtual destructor, when it\u0027s possible to reduce code duplication by using static polymorphism.",
      "parentUuid": "fcaa55b9_7e6e3b81",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}