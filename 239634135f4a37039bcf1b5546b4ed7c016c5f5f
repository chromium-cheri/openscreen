{
  "comments": [
    {
      "key": {
        "uuid": "ea387b62_1fdbb8e0",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-08T21:47:28Z",
      "side": 1,
      "message": "After substantial changes that you\u0027ve made there\u0027s one thing that\u0027s quite easy to spot here.\n\nYou always allocate enough space on stack for SynchronousTraceLogger + is_initialized field, and then possibly construct SynchronousTraceLogger or use a dummy in that space.\n\nIf you\n1) move is_initialized into SynchronousTraceLogger (or one of the base classes)\n2) add a constructor with an empty parameters list (i.e. SynchronousTraceLogger()) that sets is_initialized to false.\n\nThen SynchronousTraceLogger can be it\u0027s own uninitialized dummy when trace logging is off.\n\nYou don\u0027t need TraceCreationHelper, don\u0027t need ScopedStackStorage, and as far as I can tell, don\u0027t even need a virtual destructor.\n\nThis applies to other places where TraceCreationHelper is used.",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fcaa55b9_7e6e3b81",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-08T21:54:25Z",
      "side": 1,
      "message": "I discussed this with Yuri as well. Some of the downsides of this approach are:\n1) With the current approach, the parameters to the TRACE_SCOPED(...) call are only evaluated if TraceLogging is enabled. Else, it\u0027s just a stack allocation which only moves the stack pointer - effectively a no-op\n2) The approach you\u0027re suggesting would still incur costs associated with calling virtual methods/constructors/etc. It may not actually end up doing anything, but there are more than a few extra calls\n\nIf this weren\u0027t a place we needed the absolute maximum speed possible, I\u0027d agree. But the approach taken here is helpful in minimizing the amount of time taken when tracing isn\u0027t enabled - no extra calls, parameters aren\u0027\u0027t evaluated, just IsTracingEnabled() and moving the stack pointer\n\nThe virtual destructor I need for other reasons - the constructor and destructor of the base class are where pushes to the traces_ stack occur, in the base class.",
      "parentUuid": "ea387b62_1fdbb8e0",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "042c5e26_243f7f19",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1336186
      },
      "writtenOn": "2019-08-08T22:07:48Z",
      "side": 1,
      "message": "1) It would not\n\nconst auto TRACE_INTERNAL_UNIQUE_VAR_NAME(trace_ref_) \u003d TRACE_IS_ENABLED(category) ? SynchronousTraceLogger(category, name, __FILE__, __LINE__, ##__VA_ARGS__) : SynchronousTraceLogger();\n\n2) That would be a lot of code to put into CR comments, but if you define \"no-op\" constructors in base classes, then calling SynchronousTraceLogger() wouldn\u0027t do anything except setting is_initialized to false.\nAs for the calls to the virtual methods - you incur them anyway when you call those methods.\n\nYour scoped local variable does not have to be of the base type, it can be SynchronousTraceLogger, which means you don\u0027t actually need virtual methods.\n\n\u003eIf this weren\u0027t a place we needed the absolute maximum speed possible\nAnd yet there are virtual functions and a virtual destructor, when it\u0027s possible to reduce code duplication by using static polymorphism.",
      "parentUuid": "fcaa55b9_7e6e3b81",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b11e033_f98a2a03",
        "filename": "platform/api/trace_logging.h",
        "patchSetId": 5
      },
      "lineNbr": 62,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-08-08T22:23:42Z",
      "side": 1,
      "message": "Let\u0027s discuss this offline when I\u0027m in tomorrow\n\nA No-Op constructor would still make virtual calls to the parent classes. As would the destructor. None of these calls happen with the current approach when tracing is disabled since we are just using an empty array (TraceCretionHelper::Empty() just calls the empty constructor on ScopetStackStorage), which is the case we need to be the absolute fastest\n\nWe do need virtual methods for SynchronousTraceLogger, since we are pushing pointers to the shared traces_ stack. We could probably get around this with additional layers of indirection, but I feel that doing so would be needlessly complex\n\nThe additional benefit of this approach is that the tracing code is isolated from how it\u0027s stored. Tying the two together, as you are suggesting, will complicate the tracing code and decrease readability. With this approach, the two halves can be modified and tested separately without concern of one affecting the other\n\nBeyond this, It is worth considering that the ScopedStackStoprage class is also needed to support User Provided Arguments (see the follow up CL). So removing the dependency in this one place would not decrease complexity.",
      "parentUuid": "042c5e26_243f7f19",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 62,
        "endChar": 64
      },
      "revId": "239634135f4a37039bcf1b5546b4ed7c016c5f5f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}