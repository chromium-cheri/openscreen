{
  "comments": [
    {
      "key": {
        "uuid": "01f1e9c6_0e202ecd",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-20T22:04:31Z",
      "side": 1,
      "message": "Instead of using a unique_ptr, how about just a regular pointer and we make it part of the call contract that we expect the caller to delete the object?\n\nThe reason for this is that unique_ptr is non-copyable, which means we can\u0027t use std::bind(...) to bind this function to a function\u003cvoid()\u003e, so it will be difficult to push OnRead(...) to the TaskQueue (which expects function\u003cvoid()\u003e) for later processing",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d48561b_a58cfe72",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "I\u0027m strongly inclined to leave this as std::unique_ptr.  I haven\u0027t looked at the implementation of std::bind, but I don\u0027t think it would hurt to just write our own bind.  That way the issue of \"want-but-can\u0027t-use unique_ptr\" is left closer to the cause.",
      "parentUuid": "01f1e9c6_0e202ecd",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30882d50_bc24e89c",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "If writing our own std::bind works, I am up for that approach. My thought for a possible approach was to add a new method to the TaskRunner\n\ntemplate\u003cTType\u003e ExecutePointerTask(std::function\u003cvoid(TType*)\u003e, std::unique_ptr\u003cTType\u003e) {...}\n\nTo execute the task, then delete the UniquePtr\u003c...\u003e once it had been run.",
      "parentUuid": "6d48561b_a58cfe72",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41d28fd5_a5f2b98c",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-17T16:47:24Z",
      "side": 1,
      "message": "I\u0027m in favor of pulling this out to its own top-level class in a different header file. Specifically the definition of Packet should be moved elsewhere so we can update UdpSocket.RecieveMessage to return data in this form",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9602c90_60b7e8fd",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "I don\u0027t see why Packet should be a top-level class.  Did you have another use for this struct in mind that makes it seem independent from UdpReadCallback?",
      "parentUuid": "41d28fd5_a5f2b98c",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "455a6a70_1a58ed07",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "After writing up my code (see https://chromium-review.googlesource.com/c/openscreen/+/1627673 ) I only use the UdpReadCallback and Packet together as you expect, but they are used outside of the NetworkRunner class (specifically at the layer below NetworkRunner), so I suspect putting that in its own file (or with one of the interfaces if we split this up - discussed below) would be cleaner",
      "parentUuid": "a9602c90_60b7e8fd",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44b37461_68cdb0cf",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-17T16:58:09Z",
      "side": 1,
      "message": "Why are we combining the interfaces for the TaskRunner and the Network Waiter? I am 100% for having the same object handle both, but I think having separate interfaces would be better - that way we can pass all TaskRunner calls to an internal TaskRunner object (previously TaskRunnerImpl) and all NetworkWaiter calls to an internal NetworkWaiter object.\n\nThen the UdpReadCallback can directly refer to the internal NetworkWaiter, rather than adding an extra level of indirection and std::bind call before passing all processing along to the internal NetworkWaiter",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35b70a9f_0e8f6cc7",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "The fact that it combines two otherwise independent interfaces doesn\u0027t really preclude its use in the scenarios you described.\n\nThe reason for having a single interface is item 3 in the comment above: adding a read callback also has threading implications w.r.t. some task runner.  It\u0027s seems clearer to have those tightly coupled in this case.",
      "parentUuid": "44b37461_68cdb0cf",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed915756_9e357ea4",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "In order to make this top layer Unit Testable, we should stick some interface in between NetworkRunner and the lower layers rather than calling them directly. My opinion is that using the same interfaces for both the top layer (NetworkRunner) and lower layers (NetworkLoop / whatever we call the network handling + the task runner) is the cleanest approach, but I don\u0027t have that strong of an opinion between that and creating new interfaces for those layers\n\nThe new interfaces would have to share nearly all methods with this interface though",
      "parentUuid": "35b70a9f_0e8f6cc7",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cc9d7cc_f503e8d4",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "I like the idea of separate TaskRunner and NetworkRunner interfaces, but I think it make sense us to do either:\n\nA.  NetworkRunner subclasses TaskRunner\n\nB.  NetworkRunner has a GetTaskRunner() method.  \n\n\nI\u0027m fine with either.  I\u0027d rather go with the one that\u0027s easier to use.  Which one is that?  Well, A has easier memory management because if you call GetTaskRunner(), you have to worry about 2 lifetimes instead of 1.",
      "parentUuid": "ed915756_9e357ea4",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9db041c3_87176fba",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "The best name I can come up with is ReadRepeatedly.",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8637a279_7602599b",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "And CancelReads",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86626789_319df86c",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-15T17:59:29Z",
      "side": 1,
      "message": "Why forward declare here instead of referencing network_runner.h?",
      "range": {
        "startLine": 15,
        "startChar": 6,
        "endLine": 15,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1037a5e5_5fc79a99",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-15T18:16:26Z",
      "side": 1,
      "message": "chromium style: https://chromium.googlesource.com/chromium/src/+/master/styleguide/c++/c++.md#forward-declarations-vs_includes",
      "parentUuid": "86626789_319df86c",
      "range": {
        "startLine": 15,
        "startChar": 6,
        "endLine": 15,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}