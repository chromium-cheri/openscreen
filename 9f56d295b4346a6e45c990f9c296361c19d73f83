{
  "comments": [
    {
      "key": {
        "uuid": "08c54461_68035105",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-06T20:14:28Z",
      "side": 1,
      "message": "A mild suggestion (since Packet \"is-a\" chunk of bytes):\n\n  struct Packet : public std::array\u003cuint8_t, kUdpMaxPacketSize\u003e {\n    IPEndpoint source;\n    IPEndpoint destination;\n  };",
      "range": {
        "startLine": 33,
        "startChar": 4,
        "endLine": 34,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34ffc4bf_dd3adce3",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "08c54461_68035105",
      "range": {
        "startLine": 33,
        "startChar": 4,
        "endLine": 34,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e8cf2dd7_84076ad6",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 35,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-06T20:14:28Z",
      "side": 1,
      "message": "How do we know the pointer will be valid later when it is used (i.e., after a Packet sits in the task queue for a while)?\n\nIf it\u0027s meant to be an opaque identifier, then it can\u0027t be a pointer to an object in memory (since objects can be destroyed and the same address re-used for a different object).",
      "range": {
        "startLine": 35,
        "startChar": 4,
        "endLine": 35,
        "endChar": 22
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f55d9f3_9ea611ab",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 35,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "This has moved to be a parameter of OnRead, though I don\u0027t think it changes this issue.  The idea is that CancelReads should, in addition to removing it from our socket read pool, remove even already-read data for the socket from the TaskRunner for just this reason.  I\u0027ll add a TODO here as a reminder going forward into the implementation.",
      "parentUuid": "e8cf2dd7_84076ad6",
      "range": {
        "startLine": 35,
        "startChar": 4,
        "endLine": 35,
        "endChar": 22
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01f1e9c6_0e202ecd",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-20T22:04:31Z",
      "side": 1,
      "message": "Instead of using a unique_ptr, how about just a regular pointer and we make it part of the call contract that we expect the caller to delete the object?\n\nThe reason for this is that unique_ptr is non-copyable, which means we can\u0027t use std::bind(...) to bind this function to a function\u003cvoid()\u003e, so it will be difficult to push OnRead(...) to the TaskQueue (which expects function\u003cvoid()\u003e) for later processing",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d48561b_a58cfe72",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "I\u0027m strongly inclined to leave this as std::unique_ptr.  I haven\u0027t looked at the implementation of std::bind, but I don\u0027t think it would hurt to just write our own bind.  That way the issue of \"want-but-can\u0027t-use unique_ptr\" is left closer to the cause.",
      "parentUuid": "01f1e9c6_0e202ecd",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30882d50_bc24e89c",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "If writing our own std::bind works, I am up for that approach. My thought for a possible approach was to add a new method to the TaskRunner\n\ntemplate\u003cTType\u003e ExecutePointerTask(std::function\u003cvoid(TType*)\u003e, std::unique_ptr\u003cTType\u003e) {...}\n\nTo execute the task, then delete the UniquePtr\u003c...\u003e once it had been run.",
      "parentUuid": "6d48561b_a58cfe72",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ef9c0e5_adeca581",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-06T20:14:28Z",
      "side": 1,
      "message": "FWIW, I fixed the TaskRunner (committed yesterday) to permit any kind of \"functor-like thing\" to be used with PostTask() (lambda, std::bind result, etc.), and it now supports movable objects (such as std::unique_ptr).\n\nOOC, what\u0027s wrong with std::bind? I think I missed the part of the discussion where we talked about why we need to roll our own.",
      "parentUuid": "30882d50_bc24e89c",
      "range": {
        "startLine": 40,
        "startChar": 22,
        "endLine": 40,
        "endChar": 50
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41d28fd5_a5f2b98c",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-17T16:47:24Z",
      "side": 1,
      "message": "I\u0027m in favor of pulling this out to its own top-level class in a different header file. Specifically the definition of Packet should be moved elsewhere so we can update UdpSocket.RecieveMessage to return data in this form",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9602c90_60b7e8fd",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "I don\u0027t see why Packet should be a top-level class.  Did you have another use for this struct in mind that makes it seem independent from UdpReadCallback?",
      "parentUuid": "41d28fd5_a5f2b98c",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "455a6a70_1a58ed07",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "After writing up my code (see https://chromium-review.googlesource.com/c/openscreen/+/1627673 ) I only use the UdpReadCallback and Packet together as you expect, but they are used outside of the NetworkRunner class (specifically at the layer below NetworkRunner), so I suspect putting that in its own file (or with one of the interfaces if we split this up - discussed below) would be cleaner",
      "parentUuid": "a9602c90_60b7e8fd",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd4e0cf3_d0c7a1eb",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "Moved to udp_callbacks.h",
      "parentUuid": "455a6a70_1a58ed07",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 42,
        "endChar": 2
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44b37461_68cdb0cf",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-17T16:58:09Z",
      "side": 1,
      "message": "Why are we combining the interfaces for the TaskRunner and the Network Waiter? I am 100% for having the same object handle both, but I think having separate interfaces would be better - that way we can pass all TaskRunner calls to an internal TaskRunner object (previously TaskRunnerImpl) and all NetworkWaiter calls to an internal NetworkWaiter object.\n\nThen the UdpReadCallback can directly refer to the internal NetworkWaiter, rather than adding an extra level of indirection and std::bind call before passing all processing along to the internal NetworkWaiter",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35b70a9f_0e8f6cc7",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-28T10:33:31Z",
      "side": 1,
      "message": "The fact that it combines two otherwise independent interfaces doesn\u0027t really preclude its use in the scenarios you described.\n\nThe reason for having a single interface is item 3 in the comment above: adding a read callback also has threading implications w.r.t. some task runner.  It\u0027s seems clearer to have those tightly coupled in this case.",
      "parentUuid": "44b37461_68cdb0cf",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed915756_9e357ea4",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-28T22:24:19Z",
      "side": 1,
      "message": "In order to make this top layer Unit Testable, we should stick some interface in between NetworkRunner and the lower layers rather than calling them directly. My opinion is that using the same interfaces for both the top layer (NetworkRunner) and lower layers (NetworkLoop / whatever we call the network handling + the task runner) is the cleanest approach, but I don\u0027t have that strong of an opinion between that and creating new interfaces for those layers\n\nThe new interfaces would have to share nearly all methods with this interface though",
      "parentUuid": "35b70a9f_0e8f6cc7",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cc9d7cc_f503e8d4",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "I like the idea of separate TaskRunner and NetworkRunner interfaces, but I think it make sense us to do either:\n\nA.  NetworkRunner subclasses TaskRunner\n\nB.  NetworkRunner has a GetTaskRunner() method.  \n\n\nI\u0027m fine with either.  I\u0027d rather go with the one that\u0027s easier to use.  Which one is that?  Well, A has easier memory management because if you call GetTaskRunner(), you have to worry about 2 lifetimes instead of 1.",
      "parentUuid": "ed915756_9e357ea4",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62181187_ca0b04e1",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "I went with NetworkRunner subclasses TaskRunner (A).",
      "parentUuid": "9cc9d7cc_f503e8d4",
      "range": {
        "startLine": 55,
        "startChar": 6,
        "endLine": 55,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22c6eb00_510214f6",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 57,
      "author": {
        "id": 1002076
      },
      "writtenOn": "2019-06-06T20:14:28Z",
      "side": 1,
      "message": "This changed (see https://chromium-review.googlesource.com/c/openscreen/+/1646564 for an explanation of what didn\u0027t work and how it was fixed).",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 37
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24d365c0_6324bfff",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 57,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "Automatically changed because of inheritance change, but thanks for the heads up.",
      "parentUuid": "22c6eb00_510214f6",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 37
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9db041c3_87176fba",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "The best name I can come up with is ReadRepeatedly.",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3efd533_da7e8b15",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 75,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9db041c3_87176fba",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8637a279_7602599b",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1125619
      },
      "writtenOn": "2019-05-29T22:39:00Z",
      "side": 1,
      "message": "And CancelReads",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "792898e6_9bd7b9d9",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8637a279_7602599b",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5fc03dfd_62624096",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 79,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-06-04T16:15:57Z",
      "side": 1,
      "message": "Based on discussions with Mark and Peter, we will need to support callbacks when writes complete as-well.\n\nFor consistency in naming, how about calling them WriteAll and CancelWrite?",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b19ad3f_e6001fff",
        "filename": "platform/api/network_runner.h",
        "patchSetId": 4
      },
      "lineNbr": 79,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "How would this API be used.  I\u0027m thinking it would be:\n\n// non-blocking will detect EWOULDBLOCK\nwrite(socket, data, ...);\n// get EWOULDBLOCK, so wait for it to be free\nnetwork-\u003eWriteNext(socket, me);  // Maybe just Write?\n\n|me| is a callback that we redo the write().  There could still be a CancelWrite.\n\nThe problem that I still see with this is that if we get EWOULDBLOCK because we\u0027re just trying to write to much at once we\u0027ll just spin between EWOULDBLOCk/network-\u003eWrite (unless there\u0027s a poll/epoll/fcntl/ioctl way of getting actual socket buffer size).\n\nNow, given that\u0027s what I had in mind for writing, what would the use of WriteAll look like?  If the user doesn\u0027t have anything to write, presumably they\u0027d just repeatedly get their callback called, so should they remove it while not wanting to write?  Alternatively, should the API try to be smart and only callback once on entering the unblocked state (not sure this is trivial to detect on e.g. posix)?",
      "parentUuid": "5fc03dfd_62624096",
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86626789_319df86c",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-05-15T17:59:29Z",
      "side": 1,
      "message": "Why forward declare here instead of referencing network_runner.h?",
      "range": {
        "startLine": 15,
        "startChar": 6,
        "endLine": 15,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1037a5e5_5fc79a99",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-05-15T18:16:26Z",
      "side": 1,
      "message": "chromium style: https://chromium.googlesource.com/chromium/src/+/master/styleguide/c++/c++.md#forward-declarations-vs_includes",
      "parentUuid": "86626789_319df86c",
      "range": {
        "startLine": 15,
        "startChar": 6,
        "endLine": 15,
        "endChar": 19
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3e26ce7_28087783",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-06-05T19:48:04Z",
      "side": 1,
      "message": "Based on my understanding of the design, I thought we only wanted one instance - so shouldn\u0027t this be:\nstatic NetworkRunner* GetSingleton()\n\nOr similar?",
      "range": {
        "startLine": 20,
        "startChar": 40,
        "endLine": 20,
        "endChar": 46
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ead57e5_41831c56",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1215804
      },
      "writtenOn": "2019-06-07T19:42:39Z",
      "side": 1,
      "message": "This doesn\u0027t preclude usage as a singleton/setting it somewhere else as a singleton so IMO this is better in general.",
      "parentUuid": "d3e26ce7_28087783",
      "range": {
        "startLine": 20,
        "startChar": 40,
        "endLine": 20,
        "endChar": 46
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b65515a3_8f3adeff",
        "filename": "platform/api/network_runner_factory.h",
        "patchSetId": 4
      },
      "lineNbr": 20,
      "author": {
        "id": 1330244
      },
      "writtenOn": "2019-06-07T21:39:54Z",
      "side": 1,
      "message": "Now that NetworkRunner extends TaskRunner, should we change this back to return a TaskRunner?\nAlternatively, should the name of the class + file be updated?",
      "range": {
        "startLine": 20,
        "startChar": 25,
        "endLine": 20,
        "endChar": 38
      },
      "revId": "9f56d295b4346a6e45c990f9c296361c19d73f83",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}